---
title: 【C语言】静态顺序表-通讯录
date: 2018-05-29 21:54:55
tags: 通讯录
categories: 项目实战
copyright:
---
---
# 前言
>近期学习了自定义类型结构体以及顺序表，所以就试着利用静态顺序表模拟实现了一个通讯录。简要功能如下：
> * 初始化通讯录
 >* 添加联系人
 >* 查找联系人
 >* 删除联系人
 >* 修改联系人
 >* 按姓名排序
 >* 清空联系人
 >* 联系人列表
 >* 退出

 <!-- more -->

 ## 项目效果展示：

 ![图片加载中](/img/20185291.png)

 ![图片加载中](/img/20185292.png)

 ![图片加载中](/img/20185293.png)

 ![图片加载中](/img/20185294.png)

 ## 参考代码：
 ### Contact.h

~~~c
/***********************************************************
*                      程序名称：通讯录（静态顺序表）         *
*                      编译环境：VS2013                     *
*                      编制日期：2018.5.28                  *
*                                      -----by Hunter	  *
***********************************************************/
#ifndef __CONTACT_H__
#define __CONTACT_H__

#include <stdio.h>
#include <Windows.h>
#include <assert.h>
#include <string.h>

enum OPPTION
{
	EXIT,
	ADD,
	SEARCH,
	DEIETE,
	MODIFY,
	SORT,
	SHOW,
	EMPTY
};

typedef char datatype;

#define MAX_NAME 10
#define MAX_SEX 5
#define MAX_TEL 11
#define MAX_ADDR 30
#define MAX_SIZE 1000

typedef struct PeoInfo
{
	datatype Name[MAX_NAME];
	datatype Sex[MAX_SEX];
	int age;
	datatype Tel[MAX_TEL];
	datatype Addr[MAX_ADDR];
}PeoInfo, *pPeoInfo;

typedef struct Contact
{
	PeoInfo data[MAX_SIZE];
	int size;
}Contact,*pContact;

//初始化通讯录
void InitContact(pContact pc);
//添加联系人
void AddContact(pContact pc);
//删除联系人
void DeleteContact(pContact pc);
//修改联系人
void ModifyContact(pContact pc);
//按姓排序
void SortContact(pContact pc);
//列表联系人
void ShowContact(pContact pc);
//清空联系人
void EmptyContact(pContact pc);



#endif //__CONTACT_H__
~~~
### Contact.c
~~~c
#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"

//初始化通讯录
void InitContact(pContact pc)
{
	assert(pc);
	pc->size = 0;
	memset(pc->data, 0, sizeof(pc->data));
}
//添加联系人
void AddContact(pContact pc)
{
	assert(pc);
	if (pc->size == MAX_SIZE)
	{
		printf("\t\t\t空间不足");
		return;
	}
	printf("\t\t\t请输入姓名:>");
	scanf("%s", pc->data[pc->size].Name);
	printf("\t\t\t请输入性别:>");
	scanf("%s", pc->data[pc->size].Sex);
	printf("\t\t\t请输入年龄:>");
	scanf("%d", &pc->data[pc->size].age);
	printf("\t\t\t请输入电话号:>");
	scanf("%s", pc->data[pc->size].Tel);
	printf("\t\t\t请输入地址:>");
	scanf("%s", pc->data[pc->size].Addr);
	pc->size++;
	printf("\t\t\t添加成功\n");
}
//查找联系人
int SearchContact(pContact pc)
{
	char name[MAX_NAME];
	int i = 0;
	assert(pc);
	if (0 == pc->size)
	{
		printf("\t\t\t无此联系人\n");
		return -1;
	}
	scanf("%s", name);
	printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n");
	for (i = 0; i < pc->size; i++)
	{
		if (0 == strcmp(pc->data[i].Name, name))
		{

			printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n",
				pc->data[i].Name,
				pc->data[i].Sex,
				pc->data[i].age,
				pc->data[i].Tel,
				pc->data[i].Addr);
			return i;
		}
	}
	printf("\t\t\t无此联系人\n");
	return -1;

}
//删除联系人
void DeleteContact(pContact pc)
{
	int i = 0;
	int num = 0;
	assert(pc);
	if (0 == pc->size)
	{
		printf("\t\t\t无联系人\n");
		return;
	}
	num = SearchContact(pc);
	if (num != -1)
	{
		int n = 0;
		printf("\t\t\t确定删除？  1.yes,  2.no:>");
		scanf("%d", &n);
		if (1 == n)
		{
			for (i = num; i < (pc->size) - 1; i++)
			{
				pc->data[i] = pc->data[i + 1];

			}
			pc->size--;
			printf("\t\t\t删除成功\n");
		}
		else
		{
			return;
		}
	}

}

//交换
void Swap(pPeoInfo *a, pPeoInfo *b)
{
	pPeoInfo *Tmp;
	Tmp = *a;
	*a = *b;
	*b = Tmp;

}


//修改联系人
void ModifyContact(pContact pc)
{
	int modify = 0;
	assert(pc);
	if (0 == pc->size)
	{
		printf("\t\t\t无联系人\n");
		return;
	}
	modify = SearchContact(pc);
	if (modify != -1)
	{
		int n = 0;
		printf("\t\t\t确认修改？1.yes  2.no:>");
		scanf("%d", &n);
		if (1 == n)
		{
			printf("\t\t\t请输入姓名:>");
			scanf("%s", pc->data[modify].Name);
			printf("\t\t\t请输入性别:>");
			scanf("%s", pc->data[modify].Sex);
			printf("\t\t\t请输入年龄:>");
			scanf("%d", &pc->data[modify].age);
			printf("\t\t\t请输入电话号:>");
			scanf("%s", pc->data[modify].Tel);
			printf("\t\t\t请输入地址:>");
			scanf("%s", pc->data[modify].Addr);
			printf("\t\t\t修改成功\n");


		}
		else
		{
			return;
		}
	}


}
//按姓排序
void SortContact(pContact pc)
{
	int i = 0;
	int j = 0;
	int flag = 0;
	assert(pc);
	if (0 == pc->size)
	{
		printf("\t\t\t无联系人\n");
		return;
	}
	// 冒泡次数
	for (i = 0; i < pc->size - 1; i++)
	{
		//冒泡排序
		for (j = 0; j < pc->size - i - 1; j++)
		{
			if (strcmp(pc->data[j].Name,pc->data[j + 1].Name)>0)
			{
				Swap(&pc->data[j], &pc->data[j + 1]);
				flag = 1;
			}
		}
		if (0 == flag)
		{
			break;
		}
	}
	printf("排序成功\n");
}
//列表联系人
void ShowContact(pContact pc)
{
	int i = 0;
	assert(pc);
	if (0 == pc->size)
	{
		printf("\t\t\t无联系人\n");
		return;
	}
	printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n");
	for (i = 0; i < pc->size; i++)
	{
		printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n",
			pc->data[i].Name,
			pc->data[i].Sex,
			pc->data[i].age,
			pc->data[i].Tel,
			pc->data[i].Addr);

	}

}
//清空联系人
void EmptyContact(pContact pc)
{
	assert(pc);
	pc->size = 0;
	printf("清空成功");
}
~~~
### test.c
~~~c

#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"
void meau()
{
	printf("\t\t\t******         《通讯录》       ********\n");
	printf("\t\t\t****************************************\n");
	printf("\t\t\t****** 1.添加信息       2.查找信息******\n");
	printf("\t\t\t****** 3.删除信息       4.修改信息******\n");
	printf("\t\t\t****** 5.按姓排序       6.信息列表******\n");
	printf("\t\t\t****** 7.清空信息       8.退出    ******\n");
	printf("\t\t\t****************************************\n");
}

void test()
{
	int input = 0;
	Contact pc;
	InitContact(&pc);
	do
	{
		meau();
		printf("\t\t\t请选择:>");
		scanf("%d", &input);
		switch (input)
		{
		case ADD:
			AddContact(&pc);
			break;
		case SEARCH:
			SearchContact(&pc);
			break;
		case DEIETE:
			DeleteContact(&pc);
			break;
		case MODIFY:
			ModifyContact(&pc);
			break;
		case SORT:
			SortContact(&pc);
			break;
		case SHOW:
			ShowContact(&pc);
			break;
		case EMPTY:
			EmptyContact(&pc);
			break;
		case EXIT:
			exit(0);
			break;
		default:
			printf("\t\t\t输入有误，请重新输入:>");
			break;
		}

	} while (input);

}

int main()
{
	test();
	system("pause");
	return 0;
}

~~~
# 结语
 >今天简单实现了基于静态顺序表的通讯录，需再努力继续实现动态顺序表通讯录。               -----------------再续
