---
title: 自定义类型：结构体，枚举，联合
date: 2018-05-30 22:02:36
tags: 结构体
categories: C语言知识及题集
copyright:
---
---
# 前言

# 结构体
## 结构体的声明
### 结构的基础知识
>结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
### 结构的声明
~~~c
struct tag
{
	member_list; //成员列表
}variable_list;	//变量列表也称类型名，属于全局变量
~~~
>*注意：程序应尽可能少定义全局变量，在程序中到处引用全局变量，会导致程序难以控制，容易出错。且声明不占用内存*

**例如描述一个学生**
~~~c
struct Stu
{
	char name[20];//名字
	int age;//年龄
	char sex[5];//姓名
	char telp[11];//电话号
	char id[20];//学号
};//分号不能丢
~~~
### 特殊的声明
>特殊声明就是不完全声明又叫匿名结构体类型声明

~~~c
//匿名结构体类型声明
struct
{
	int a;
	char b;
	float c;
}x;

struct
{
	int a;
	char b;
	float c;
}a[20],*p;
~~~
>*对于上面声明，均省略了结构体标签，而对于匿名结构体类型声明，编译器会把上面两个声明当成**完全不同**的 两个类型，所以对于**p = &x**是非法的*
## 结构的成员
>结构的成员可以是标量，数组，指针，甚至是其他结构体。
### 结构体成员的访问
>* 结构体变量访问成员： 结构变量成员通过点操作符（.）访问，点操作符接收两个操作数。
>* 结构体访问指向变量的成员： 有时候我们得到不是一个结构体变量，而是一个指向结构体的指针，就应该用（->）操作符。

~~~c
struct Stu
{
	char name[20];//名字
	int age;//年龄
}s;

void print(struct Stu* pc)
{
	printf("%s,%d\n",(*pc).name,(*pc).age);
	printf("%s,%d\n", pc->name, pc->age);

}
~~~
## 结构自引用
>简而言之就是在结构中包含一个类型为结构本身的成员

~~~c
typedef struct Node
{
  int data;
  struct Node* next;
}Node;
~~~
## 结构的不完整声明
~~~c
struct B;

struct A
{
  int a;
  struct B* pb;
};

struct B
{
  int b;
  struct A* pa;
};
~~~
## 结构体变量定义及初始化
>有了结构体类型，定义及初始化就很简单了

~~~c
struct Stu
{
	int x;
	int y;
}p1; //声明类型同时定义变量p1
struct Stu p2;//定义结构体变量p2

struct Stu P3 = { x, y };//定义变量同时初始化

struct Po
{
	char name[20];
	int age;
};
struct Po s = { "zhangsan", 20 };//定义变量同时初始化

~~~
## 结构体内存对齐
>目前，我们已经掌握了结构体的基本使用了，现在来开始讨论一个问题：**计算结构的大小**。当然也是一个热门考点：**结构体内存对齐**

**如何计算？**

*结构体内存对齐规则：*
> * 第一个成员在与结构体变量偏移量为0的地址处；
* 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。**对齐数**=编译器默认对齐数 与该成员自身大小中的最小值。**VS默认值为8，linux中gcc默认值为4.**
* 结构体总大小为最大对齐数的整数倍；
* 如果嵌套了结构体的情况，嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的大小就是所有对齐数中最大对齐数的整数倍。

**注意：**
~~~c
#pragma pack（n）    //n表示系统默认最大对齐数
...
#pragma pack（）     //使用完应立即取消自定义设置
~~~

**为什么存在内存对齐？**
>**平台原因(移植原因):**
* 不是所有硬件平台都能访问任意地址上的数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则肯呢个抛出硬件异常。
>
>**性能原因：**
* 数据结构（尤其是栈）应该尽可能的在自然边界上对齐，原因在于：访问未对齐的内存，处理器需要两次访问，而访问对齐内存，处理器只需访问一次。

*总的来说：*结构体内存对齐就是用空间换取时间的做法，而我们在设计的时候既要满足内存对齐，还要满足节省空间，那么唯一做法：**让占用空间小的成员尽可能集中在一起。**

~~~c
//练习一
struct S1
{
  double d;
  //0-7
  char c;
  //8
  int i;
  //11-15
};
printf("%d\n",sizeof(struct S1));        //16

//练习二
struct S2
{
  char a;
  //0
  struct S1 S;
  //8-23
  double f;
  //24-31
};
printf("%d\n",sizeof(struct S2));        //32
~~~
*附加：*

~~~c
//宏，表示结构体成员变量在内存中偏移量包含于头文件#include <stddef.h>
offsetof(struct S,   A);

宏实现：（size_t）&(((S*)0)->m)

~~~


## 结构体传参
>讲解函数栈桢的时候，我们知道函数传参是需要参数压栈的，如果传递的是一个结构体对象，而结构体过大，参数压栈的系统开销就会很大，所以导致系统性能下降。

**结论**

>结构体传参的时候要传**结构体指针。**

## 位段
### 什么是位段？

*位段声明与结构体类型相似，有两个不同：*
> * 位段成员必须int 、unsigned int 或 signed int。
* 位段成员名后面有一个冒号和一个数字。

### 位段内存分配

>* 

~~~c
~~~
~~~c
~~~
