<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【C语言】动态顺序表 + 文件存储 = 通讯录]]></title>
    <url>%2F2018%2F06%2F02%2F2018530%2F</url>
    <content type="text"><![CDATA[前言 在前面曾用静态、动态顺序表两种方式实现通讯录，但每次运行程序我们都得重新输入，之前输入的成员信息并不会保存，而现实中，通讯录里的信息创建后是永久保存的，除非你删除它，今天我们就来模拟一下如何将数据存储在文件中，当下一次运行时加载一下即可，这种做法更贴合实际。 程序中会用到与文件操作相关的函数，提前介绍一下： fopen 它的函数原型为：FILEfopen(const char filename,const char *mode) ，filename:创建文件的名字；mode:允许进入文件的类型;简单来说这个文件的作用就是打开一个文件流；与fclose:关闭文件流配套使用. perror: 它的函数原型为：void perror(const char * string) ,这是一种报告文件错误的函数；后面包括一个分号和一个空格，然后打印出一条用于解释errno当前错误代码的信息; fwrite: 它的函数原型为：size_t fwrite(const void buffer,size_t size,size_t count,FILEstream) ,buffer:数据写入的体格缓冲区； 通讯录简要功能： 初始化通讯录 添加联系人 查找联系人 删除联系人 修改联系人 按姓名排序 清空联系人 联系人列表 检查容量 加载文件 保存文件 销毁通讯录 退出 参考代码：Contact.h：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/************************************************************ 程序名称：通讯录（静态顺序表） ** 编译环境：VS2013 ** 编制日期：2018.5.29 ** -----by Hunter ************************************************************/#ifndef __CONTACT_H__#define __CONTACT_H__#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;enum OPPTION&#123; EXIT, ADD, SEARCH, DEIETE, MODIFY, SORT, SHOW, EMPTY&#125;;typedef char datatype;#define MAX_NAME 10#define MAX_SEX 5#define MAX_TEL 11#define MAX_ADDR 30#define MAX_SIZE 1000#define FILE_NAME "contact.dat"typedef struct PeoInfo&#123; datatype Name[MAX_NAME]; datatype Sex[MAX_SEX]; int age; datatype Tel[MAX_TEL]; datatype Addr[MAX_ADDR];&#125;PeoInfo, *pPeoInfo;typedef struct Contact&#123; pPeoInfo data; int size; int capacity;&#125;Contact, *pContact;//初始化通讯录void InitContact(pContact pc);//添加联系人void AddContact(pContact pc);//删除联系人void DeleteContact(pContact pc);//查找联系人int SearchContact(pContact pc);//修改联系人void ModifyContact(pContact pc);//按姓排序void SortContact(pContact pc);//列表联系人void ShowContact(pContact pc);//清空联系人void EmptyContact(pContact pc);//销毁void DestoryContact(pContact pc);//加载void LoadContact(pContact pc);//保存void SaveContact(pContact pc);#endif //__CONTACT_H__ Contact.c： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304#define _CRT_SECURE_NO_WARNINGS 1#include "contact.h"//检查扩容void CheckCapacity(pContact pc)&#123; assert(pc); pPeoInfo *p = NULL; if (pc-&gt;size == pc-&gt;capacity) &#123; p = (pPeoInfo)realloc(pc-&gt;data, (pc-&gt;capacity + 2)*sizeof(PeoInfo)); if (p != NULL) &#123; pc-&gt;data = p; &#125; else &#123; printf("\t\t\t增容失败"); exit(EXIT_FAILURE); &#125; pc-&gt;capacity += 2; printf("\t\t\t增容成功\n"); &#125;&#125;//加载void LoadContact(pContact pc)&#123; int i = 0; FILE* pfRead = fopen("contact.dat", "r"); PeoInfo tmp = &#123; 0 &#125;; //创建临时变量保存每次读取的信息 assert(pc); if (pfRead == NULL) &#123; perror("the file to read"); exit(EXIT_FAILURE); &#125; while (fread(&amp;tmp, sizeof(PeoInfo), 1, pfRead)) &#123; CheckCapacity(pc); pc-&gt;data[i] = tmp; i++; pc-&gt;size++; &#125; fclose(pfRead); pfRead = NULL;&#125;//保存void SaveContact(pContact pc)&#123; assert(pc); FILE *pfwrite = fopen("contact.dat", "w"); int i = 0; if (pfwrite == NULL) &#123; perror("the file to write"); exit(EXIT_FAILURE); &#125; for (i = 0; i&lt;pc-&gt;size; i++) &#123; fwrite(pc-&gt;data+ i, sizeof(PeoInfo), 1, pfwrite); &#125; fclose(pfwrite); pfwrite = NULL;&#125;//初始化通讯录void InitContact(pContact pc)&#123; assert(pc); pc-&gt;size = 0; pc-&gt;capacity = 3; pc-&gt;data = (pPeoInfo)malloc((pc-&gt;capacity)*sizeof(PeoInfo)); if (pc-&gt;data == NULL) &#123; printf("\t\t\t内存分配失败"); exit(EXIT_FAILURE); &#125; memset(pc-&gt;data, 0, sizeof(pc-&gt;data)); LoadContact(pc);&#125;//添加联系人void AddContact(pContact pc)&#123; assert(pc); if (pc-&gt;size == MAX_SIZE) &#123; printf("\t\t\t空间不足"); return; &#125; CheckCapacity(pc); printf("\t\t\t请输入姓名:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Name); printf("\t\t\t请输入性别:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Sex); printf("\t\t\t请输入年龄:&gt;"); scanf("%d", &amp;pc-&gt;data[pc-&gt;size].age); printf("\t\t\t请输入电话号:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Tel); printf("\t\t\t请输入地址:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Addr); pc-&gt;size++; printf("\t\t\t添加成功\n");&#125;//查找联系人int SearchContact(pContact pc)&#123; char name[MAX_NAME]; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无此联系人\n"); return -1; &#125; printf("\t\t\t"); scanf("%s", name); printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n"); for (i = 0; i &lt; pc-&gt;size; i++) &#123; if (0 == strcmp(pc-&gt;data[i].Name, name)) &#123; printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n", pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); return i; &#125; &#125; printf("\t\t\t无此联系人\n"); return -1;&#125;//删除联系人void DeleteContact(pContact pc)&#123; int i = 0; int num = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; num = SearchContact(pc); if (num != -1) &#123; int n = 0; printf("\t\t\t确定删除？ 1.yes, 2.no:&gt;"); printf("\t\t\t"); scanf("%d", &amp;n); if (1 == n) &#123; for (i = num; i &lt; (pc-&gt;size) - 1; i++) &#123; pc-&gt;data[i] = pc-&gt;data[i + 1]; &#125; pc-&gt;size--; printf("\t\t\t删除成功\n"); &#125; else &#123; return; &#125; &#125;&#125;//交换void Swap(pPeoInfo *a, pPeoInfo *b)&#123; pPeoInfo *Tmp; Tmp = *a; *a = *b; *b = Tmp;&#125;//修改联系人void ModifyContact(pContact pc)&#123; int modify = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; modify = SearchContact(pc); if (modify != -1) &#123; int n = 0; printf("\t\t\t确认修改？1.yes 2.no:&gt;"); printf("\t\t\t"); scanf("%d", &amp;n); if (1 == n) &#123; printf("\t\t\t请输入姓名:&gt;"); scanf("%s", pc-&gt;data[modify].Name); printf("\t\t\t请输入性别:&gt;"); scanf("%s", pc-&gt;data[modify].Sex); printf("\t\t\t请输入年龄:&gt;"); scanf("%d", &amp;pc-&gt;data[modify].age); printf("\t\t\t请输入电话号:&gt;"); scanf("%s", pc-&gt;data[modify].Tel); printf("\t\t\t请输入地址:&gt;"); scanf("%s", pc-&gt;data[modify].Addr); printf("\t\t\t修改成功\n"); &#125; else &#123; return; &#125; &#125;&#125;//按姓排序void SortContact(pContact pc)&#123; int i = 0; int j = 0; int flag = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; // 冒泡次数 for (i = 0; i &lt; pc-&gt;size - 1; i++) &#123; //冒泡排序 for (j = 0; j &lt; pc-&gt;size - i - 1; j++) &#123; if (strcmp(pc-&gt;data[j].Name, pc-&gt;data[j + 1].Name)&gt;0) &#123; Swap(&amp;pc-&gt;data[j], &amp;pc-&gt;data[j + 1]); flag = 1; &#125; &#125; if (0 == flag) &#123; break; &#125; &#125; printf("排序成功\n");&#125;//列表联系人void ShowContact(pContact pc)&#123; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n"); for (i = 0; i &lt; pc-&gt;size; i++) &#123; printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n", pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); &#125;&#125;//清空联系人void EmptyContact(pContact pc)&#123; assert(pc); pc-&gt;size = 0; printf("\t\t\t清空成功");&#125;//销毁通讯录void DestoryContact(pContact pc)&#123; assert(pc); SaveContact(pc); free(pc-&gt;data); pc-&gt;data = NULL; pc-&gt;capacity = 0; pc-&gt;size = 0; printf("\t\t\t销毁成功");&#125; test.c： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define _CRT_SECURE_NO_WARNINGS 1#include "contact.h"void meau()&#123; printf("\t\t\t****** 《通讯录》 ********\n"); printf("\t\t\t****************************************\n"); printf("\t\t\t****** 1.添加信息 2.查找信息******\n"); printf("\t\t\t****** 3.删除信息 4.修改信息******\n"); printf("\t\t\t****** 5.按姓排序 6.信息列表******\n"); printf("\t\t\t****** 7.清空信息 0.退出 ******\n"); printf("\t\t\t****************************************\n");&#125;void test()&#123; int input = 0; Contact pc; InitContact(&amp;pc); do &#123; meau(); printf("\t\t\t请选择:&gt;"); scanf("%d", &amp;input); switch (input) &#123; case ADD: AddContact(&amp;pc); break; case SEARCH: SearchContact(&amp;pc); break; case DEIETE: DeleteContact(&amp;pc); break; case MODIFY: ModifyContact(&amp;pc); break; case SORT: SortContact(&amp;pc); break; case SHOW: ShowContact(&amp;pc); break; case EMPTY: EmptyContact(&amp;pc); break; case EXIT: break; default: printf("\t\t\t输入有误，请重新输入:&gt;"); break; &#125; &#125; while (input);&#125;int main()&#123; Contact pc; test(); //销毁通讯录 DestoryContact(&amp;pc); system("pause"); return 0;&#125; 结语： 最初的自己是个编程菜鸟，然而通过努力的学习，现在也能逐渐的自己写小程序了，相信这就是一种进步，暂不希望自己能有多强大。只要每一步走的充实，我相信一定会有好的回报，且行且努力！]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>通讯录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆序字符串问题]]></title>
    <url>%2F2018%2F06%2F01%2F201861%2F</url>
    <content type="text"><![CDATA[题目 有一个字符数组的内容为: student a am i ,请将数组的内容改为 i am a student 要求： 不能使用库函数。只能开辟有限个空间（空间个数和字符串的长度无关）。 算法分析 先将整个字符串整体逆置，再以每个单词为对象局部逆置（这时判断条件复杂一些）；这里逆置时，需要一个逆置函数，需要两个参数，首指针和尾指针，由这两个指针锁定一个区域，将里面的字符从头至尾逆置 注意： 最后一次跳出while循环时，相当于*pcur==’\0’,所以最后这个单词没有逆置，需要再次调用逆置函数 if(表达式){语句1}语句2；这样的结构，无论if表达式成立与否，语句2都会执行的 效果展示 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt; #include &lt;assert.h&gt; int my_strlen(const char *str) &#123; int count = 0; assert(str); while(*str++) &#123; count++; &#125; return count; &#125; void reverse_str(char *left,char *right) &#123; assert(left); assert(right); while(left &lt; right) &#123; char temp = *left; *left = *right; *right = temp; left++; right--; &#125; &#125; void reverse(char *str) &#123; assert(str); char *left = str; char *right = str + my_strlen(str) - 1; reverse_str(left,right); &#125; int main() &#123; char arr[] = "student a am i"; printf("请逆转每个单词:%s\n\n",arr); char *pcur = arr; //逆序字符串 reverse(arr); //逆序单词 while(*pcur) &#123; char *start = pcur; while(*pcur != ' '&amp;&amp;*pcur != '\0') &#123; pcur++; &#125; reverse_str(start,pcur-1); if(*pcur == ' ') pcur++; &#125; printf("逆转后的结果：\n"); puts(arr); return 0; &#125;]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>逆序字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义类型：结构体，枚举，联合]]></title>
    <url>%2F2018%2F05%2F31%2F201862%2F</url>
    <content type="text"><![CDATA[前言 对于C语言的学习，我们知道有基本数据类型，指针类型，自定义类型等。今天一起来探讨一下自定义类型。 结构体结构体的声明结构的基础知识 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。 结构的声明1234struct tag&#123; member_list; //成员列表&#125;variable_list; //变量列表也称类型名，属于全局变量 注意：程序应尽可能少定义全局变量，在程序中到处引用全局变量，会导致程序难以控制，容易出错。且声明不占用内存 例如描述一个学生12345678struct Stu&#123; char name[20];//名字 int age;//年龄 char sex[5];//姓名 char telp[11];//电话号 char id[20];//学号&#125;;//分号不能丢 特殊的声明 特殊声明就是不完全声明又叫匿名结构体类型声明 1234567891011121314//匿名结构体类型声明struct&#123; int a; char b; float c;&#125;x;struct&#123; int a; char b; float c;&#125;a[20],*p; 对于上面声明，均省略了结构体标签，而对于匿名结构体类型声明，编译器会把上面两个声明当成完全不同的 两个类型，所以对于p = &amp;x是非法的 结构的成员 结构的成员可以是标量，数组，指针，甚至是其他结构体。 结构体成员的访问 结构体变量访问成员： 结构变量成员通过点操作符（.）访问，点操作符接收两个操作数。 结构体访问指向变量的成员： 有时候我们得到不是一个结构体变量，而是一个指向结构体的指针，就应该用（-&gt;）操作符。 123456789101112struct Stu&#123; char name[20];//名字 int age;//年龄&#125;s;void print(struct Stu* pc)&#123; printf("%s,%d\n",(*pc).name,(*pc).age); printf("%s,%d\n", pc-&gt;name, pc-&gt;age);&#125; 结构自引用 简而言之就是在结构中包含一个类型为结构本身的成员 12345typedef struct Node&#123; int data; struct Node* next;&#125;Node; 结构的不完整声明12345678910111213struct B;struct A&#123; int a; struct B* pb;&#125;;struct B&#123; int b; struct A* pa;&#125;; 结构体变量定义及初始化 有了结构体类型，定义及初始化就很简单了 123456789101112131415struct Stu&#123; int x; int y;&#125;p1; //声明类型同时定义变量p1struct Stu p2;//定义结构体变量p2struct Stu P3 = &#123; x, y &#125;;//定义变量同时初始化struct Po&#123; char name[20]; int age;&#125;;struct Po s = &#123; "zhangsan", 20 &#125;;//定义变量同时初始化 结构体内存对齐 目前，我们已经掌握了结构体的基本使用了，现在来开始讨论一个问题：计算结构的大小。当然也是一个热门考点：结构体内存对齐 如何计算？ 结构体内存对齐规则： 第一个成员在与结构体变量偏移量为0的地址处； 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数=编译器默认对齐数 与该成员自身大小中的最小值。VS默认值为8，linux中gcc默认值为4. 结构体总大小为最大对齐数的整数倍； 如果嵌套了结构体的情况，嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的大小就是所有对齐数中最大对齐数的整数倍。 注意：123#pragma pack（n） //n表示系统默认最大对齐数...#pragma pack（） //使用完应立即取消自定义设置 为什么存在内存对齐？ 平台原因(移植原因): 不是所有硬件平台都能访问任意地址上的数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则肯呢个抛出硬件异常。 性能原因： 数据结构（尤其是栈）应该尽可能的在自然边界上对齐，原因在于：访问未对齐的内存，处理器需要两次访问，而访问对齐内存，处理器只需访问一次。 总的来说：结构体内存对齐就是用空间换取时间的做法，而我们在设计的时候既要满足内存对齐，还要满足节省空间，那么唯一做法：让占用空间小的成员尽可能集中在一起。 1234567891011121314151617181920212223//练习一struct S1&#123; double d; //0-7 char c; //8 int i; //11-15&#125;;printf("%d\n",sizeof(struct S1)); //16//练习二struct S2&#123; char a; //0 struct S1 S; //8-23 double f; //24-31&#125;;printf("%d\n",sizeof(struct S2)); //32 附加： 1234//宏，表示结构体成员变量在内存中偏移量包含于头文件#include &lt;stddef.h&gt;offsetof(struct S, A);宏实现：（size_t）&amp;(((S*)0)-&gt;m) 结构体传参 讲解函数栈桢的时候，我们知道函数传参是需要参数压栈的，如果传递的是一个结构体对象，而结构体过大，参数压栈的系统开销就会很大，所以导致系统性能下降。 结论 结构体传参的时候要传结构体指针。 位段什么是位段？位段声明与结构体类型相似，有两个不同： 位段成员必须int 、unsigned int 或 signed int。 位段成员名后面有一个冒号和一个数字。 位段内存分配 位段成员可以是int 、unsigned int、signed int、或者char(整形家族)类型。 位段的空间上按四个字节（int）或者一个字节（char）方式开辟 位段涉及很多不确定因素，位段是不跨平台的，注重可移植性程序因避免使用位段。 eg：12345678struct A&#123; int a:2; int b:5; int c:10; int d:30;&#125;;printf("%d",sizeof(struct A)); //8 位段跨平台问题 int位段当成有符号还是无符号是不确定的 位段中最大位数目不确定的 位段中成员是从左到右还是从右到左是不确定的 当一个结构体包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的还是利用，是不确定的 总结 跟结构相比，位段可以达到同样的效果，还节省空间，但是因为存在跨平台问题，所以运用的就不是很多了。 枚举 枚举顾名思义就是一一列举。比如：星期、颜色、性别等； 枚举类型定义123456enum Color&#123; RED, GRENE, BLUE&#125;; 以上定义的enum Color 就是枚举类型，{}中内容就是可能取值，也叫枚举常量，默认从零开始一次递增1，当然有时候也可以自定义赋值：123456enum Color&#123; RED = 1, GREEN = 4, BLUE = 8&#125;; 枚举优点 增加代码可读性与可维护性 与#define相比有类型检查，更加严谨 防止命名污染 便于调试 使用方便，一次可定义多个常量 联合（共用体）联合定义 联合也是一种特殊自定义类型，该类型定义变量也包含一系列成员，特征是这些成员公用一块空间。 eg 12345678910//联合类型声明union Un&#123; char c; int i;&#125;;//联合变量的定义union Un un;//计算变量大小printf("%d",sizeof(un)); //4 联合特点 联合成员公用一块内存空间，这样一个联合变量大小，至少是最大成员大小。 经典应用 判断当前计算机大小端存储： 123456789101112int CheckSystem（）&#123; union Un &#123; int a; char i; &#125;un; un.a = 1; //返回为1,小端存储 //返回为0，大端存储 return nu.i;&#125; 联合大小的计算 联合大小至少是最大成员大小 当最大成员大小不是最大对齐数整数倍时，就要对齐到最大对齐数的整数倍 eg123456789101112union UN1&#123; char arr[5]; int i;&#125;;union UN2&#123; short c[7]; int i;&#125;;printf("%d",sizeof(union UN1)); //8printf("%d",sizeof(union UN2)); //16 结构体与联合巧妙使用：12345678910111213141516//将long类型ip地址，转换为电分十进制形式union ip_addr&#123; unsigned long addr; struct &#123; unsigned char c1; unsigned char c2; unsigned char c3; unsigned char c4; &#125;ip; union ip_addr my_ip; my_ip.addr = 176238749; printf("%d.%d.%d.%d",my_ip.ip.c4,my_ip.ip.c3,my_ip.ip.c2,my_ip.ip.c1,);&#125; 结语 通过自定义类型学习，掌握了内存对齐等相关运用，以及如何检验大小端问题。好好学习，天天编程]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言】静态(动态)顺序表-通讯录]]></title>
    <url>%2F2018%2F05%2F29%2F2018529%2F</url>
    <content type="text"><![CDATA[前言 近期学习了自定义类型结构体以及顺序表，所以就试着利用顺序表模拟实现了一个通讯录。 简要功能如下： 初始化通讯录 添加联系人 查找联系人 删除联系人 修改联系人 按姓名排序 清空联系人 联系人列表 退出 项目效果展示： 静态顺序表参考代码：Contact.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************ 程序名称：通讯录（静态顺序表） ** 编译环境：VS2013 ** 编制日期：2018.5.28 ** -----by Hunter ************************************************************/#ifndef __CONTACT_H__#define __CONTACT_H__#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;enum OPPTION&#123; EXIT, ADD, SEARCH, DEIETE, MODIFY, SORT, SHOW, EMPTY&#125;;typedef char datatype;#define MAX_NAME 10#define MAX_SEX 5#define MAX_TEL 11#define MAX_ADDR 30#define MAX_SIZE 1000typedef struct PeoInfo&#123; datatype Name[MAX_NAME]; datatype Sex[MAX_SEX]; int age; datatype Tel[MAX_TEL]; datatype Addr[MAX_ADDR];&#125;PeoInfo, *pPeoInfo;typedef struct Contact&#123; PeoInfo data[MAX_SIZE]; int size;&#125;Contact,*pContact;//初始化通讯录void InitContact(pContact pc);//添加联系人void AddContact(pContact pc);//查找联系人int SearchContact(pContact pc);//删除联系人void DeleteContact(pContact pc);//修改联系人void ModifyContact(pContact pc);//按姓排序void SortContact(pContact pc);//列表联系人void ShowContact(pContact pc);//清空联系人void EmptyContact(pContact pc);#endif //__CONTACT_H__ Contact.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#define _CRT_SECURE_NO_WARNINGS 1#include "contact.h"//初始化通讯录void InitContact(pContact pc)&#123; assert(pc); pc-&gt;size = 0; memset(pc-&gt;data, 0, sizeof(pc-&gt;data));&#125;//添加联系人void AddContact(pContact pc)&#123; assert(pc); if (pc-&gt;size == MAX_SIZE) &#123; printf("\t\t\t空间不足"); return; &#125; printf("\t\t\t请输入姓名:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Name); printf("\t\t\t请输入性别:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Sex); printf("\t\t\t请输入年龄:&gt;"); scanf("%d", &amp;pc-&gt;data[pc-&gt;size].age); printf("\t\t\t请输入电话号:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Tel); printf("\t\t\t请输入地址:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Addr); pc-&gt;size++; printf("\t\t\t添加成功\n");&#125;//查找联系人int SearchContact(pContact pc)&#123; char name[MAX_NAME]; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无此联系人\n"); return -1; &#125; scanf("%s", name); printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n"); for (i = 0; i &lt; pc-&gt;size; i++) &#123; if (0 == strcmp(pc-&gt;data[i].Name, name)) &#123; printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n", pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); return i; &#125; &#125; printf("\t\t\t无此联系人\n"); return -1;&#125;//删除联系人void DeleteContact(pContact pc)&#123; int i = 0; int num = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; num = SearchContact(pc); if (num != -1) &#123; int n = 0; printf("\t\t\t确定删除？ 1.yes, 2.no:&gt;"); scanf("%d", &amp;n); if (1 == n) &#123; for (i = num; i &lt; (pc-&gt;size) - 1; i++) &#123; pc-&gt;data[i] = pc-&gt;data[i + 1]; &#125; pc-&gt;size--; printf("\t\t\t删除成功\n"); &#125; else &#123; return; &#125; &#125;&#125;//交换void Swap(pPeoInfo *a, pPeoInfo *b)&#123; pPeoInfo *Tmp; Tmp = *a; *a = *b; *b = Tmp;&#125;//修改联系人void ModifyContact(pContact pc)&#123; int modify = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; modify = SearchContact(pc); if (modify != -1) &#123; int n = 0; printf("\t\t\t确认修改？1.yes 2.no:&gt;"); scanf("%d", &amp;n); if (1 == n) &#123; printf("\t\t\t请输入姓名:&gt;"); scanf("%s", pc-&gt;data[modify].Name); printf("\t\t\t请输入性别:&gt;"); scanf("%s", pc-&gt;data[modify].Sex); printf("\t\t\t请输入年龄:&gt;"); scanf("%d", &amp;pc-&gt;data[modify].age); printf("\t\t\t请输入电话号:&gt;"); scanf("%s", pc-&gt;data[modify].Tel); printf("\t\t\t请输入地址:&gt;"); scanf("%s", pc-&gt;data[modify].Addr); printf("\t\t\t修改成功\n"); &#125; else &#123; return; &#125; &#125;&#125;//按姓排序void SortContact(pContact pc)&#123; int i = 0; int j = 0; int flag = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; // 冒泡次数 for (i = 0; i &lt; pc-&gt;size - 1; i++) &#123; //冒泡排序 for (j = 0; j &lt; pc-&gt;size - i - 1; j++) &#123; if (strcmp(pc-&gt;data[j].Name,pc-&gt;data[j + 1].Name)&gt;0) &#123; Swap(&amp;pc-&gt;data[j], &amp;pc-&gt;data[j + 1]); flag = 1; &#125; &#125; if (0 == flag) &#123; break; &#125; &#125; printf("排序成功\n");&#125;//列表联系人void ShowContact(pContact pc)&#123; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n"); for (i = 0; i &lt; pc-&gt;size; i++) &#123; printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n", pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); &#125;&#125;//清空联系人void EmptyContact(pContact pc)&#123; assert(pc); pc-&gt;size = 0; printf("清空成功");&#125; test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#define _CRT_SECURE_NO_WARNINGS 1#include "contact.h"void meau()&#123; printf("\t\t\t****** 《通讯录》 ********\n"); printf("\t\t\t****************************************\n"); printf("\t\t\t****** 1.添加信息 2.查找信息******\n"); printf("\t\t\t****** 3.删除信息 4.修改信息******\n"); printf("\t\t\t****** 5.按姓排序 6.信息列表******\n"); printf("\t\t\t****** 7.清空信息 0.退出 ******\n"); printf("\t\t\t****************************************\n");&#125;void test()&#123; int input = 0; Contact pc; InitContact(&amp;pc); do &#123; meau(); printf("\t\t\t请选择:&gt;"); scanf("%d", &amp;input); switch (input) &#123; case ADD: AddContact(&amp;pc); break; case SEARCH: SearchContact(&amp;pc); break; case DEIETE: DeleteContact(&amp;pc); break; case MODIFY: ModifyContact(&amp;pc); break; case SORT: SortContact(&amp;pc); break; case SHOW: ShowContact(&amp;pc); break; case EMPTY: EmptyContact(&amp;pc); break; case EXIT: exit(0); break; default: printf("\t\t\t输入有误，请重新输入:&gt;"); break; &#125; &#125; while (input);&#125;int main()&#123; test(); system("pause"); return 0;&#125; 动态顺序表参考代码Contact.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************************************************************ 程序名称：通讯录（静态顺序表） ** 编译环境：VS2013 ** 编制日期：2018.5.28 ** -----by Hunter ************************************************************/#ifndef __CONTACT_H__#define __CONTACT_H__#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;enum OPPTION&#123; EXIT, ADD, SEARCH, DEIETE, MODIFY, SORT, SHOW, EMPTY&#125;;typedef char datatype;#define MAX_NAME 10#define MAX_SEX 5#define MAX_TEL 11#define MAX_ADDR 30#define MAX_SIZE 1000typedef struct PeoInfo&#123; datatype Name[MAX_NAME]; datatype Sex[MAX_SEX]; int age; datatype Tel[MAX_TEL]; datatype Addr[MAX_ADDR];&#125;PeoInfo, *pPeoInfo;typedef struct Contact&#123; pPeoInfo data; int size; int capacity;&#125;Contact, *pContact;//初始化通讯录void InitContact(pContact pc);//添加联系人void AddContact(pContact pc);//删除联系人void DeleteContact(pContact pc);//查找联系人int SearchContact(pContact pc);//修改联系人void ModifyContact(pContact pc);//按姓排序void SortContact(pContact pc);//列表联系人void ShowContact(pContact pc);//清空联系人void EmptyContact(pContact pc);//销毁void DestoryContact(pContact pc);#endif //__CONTACT_H__ Contact.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255#define _CRT_SECURE_NO_WARNINGS 1#include "contact.h"//初始化通讯录void InitContact(pContact pc)&#123; assert(pc); pc-&gt;size = 0; pc-&gt;capacity = 3; pc-&gt;data = (pPeoInfo)malloc((pc-&gt;capacity)*sizeof(PeoInfo)); if (pc-&gt;data == NULL) &#123; printf("\t\t\t内存分配失败"); exit(EXIT_FAILURE); &#125; memset(pc-&gt;data,0,sizeof(pc-&gt;data));&#125;//检查扩容void CheckCapacity(pContact pc)&#123; assert(pc); pPeoInfo *p = NULL; if (pc-&gt;size == pc-&gt;capacity) &#123; p = (pPeoInfo)realloc(pc-&gt;data, (pc-&gt;capacity + 2)*sizeof(PeoInfo)); if (p != NULL) &#123; pc-&gt;data = p; &#125; else &#123; printf("\t\t\t增容失败"); exit(EXIT_FAILURE); &#125; pc-&gt;capacity += 2; printf("\t\t\t增容成功\n"); &#125;&#125;//添加联系人void AddContact(pContact pc)&#123; assert(pc); if (pc-&gt;size == MAX_SIZE) &#123; printf("\t\t\t空间不足"); return; &#125; CheckCapacity(pc); printf("\t\t\t请输入姓名:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Name); printf("\t\t\t请输入性别:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Sex); printf("\t\t\t请输入年龄:&gt;"); scanf("%d", &amp;pc-&gt;data[pc-&gt;size].age); printf("\t\t\t请输入电话号:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Tel); printf("\t\t\t请输入地址:&gt;"); scanf("%s", pc-&gt;data[pc-&gt;size].Addr); pc-&gt;size++; printf("\t\t\t添加成功\n");&#125;//查找联系人int SearchContact(pContact pc)&#123; char name[MAX_NAME]; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无此联系人\n"); return -1; &#125; printf("\t\t\t"); scanf("%s", name); printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n"); for (i = 0; i &lt; pc-&gt;size; i++) &#123; if (0 == strcmp(pc-&gt;data[i].Name, name)) &#123; printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n", pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); return i; &#125; &#125; printf("\t\t\t无此联系人\n"); return -1;&#125;//删除联系人void DeleteContact(pContact pc)&#123; int i = 0; int num = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; num = SearchContact(pc); if (num != -1) &#123; int n = 0; printf("\t\t\t确定删除？ 1.yes, 2.no:&gt;"); printf("\t\t\t"); scanf("%d", &amp;n); if (1 == n) &#123; for (i = num; i &lt; (pc-&gt;size) - 1; i++) &#123; pc-&gt;data[i] = pc-&gt;data[i + 1]; &#125; pc-&gt;size--; printf("\t\t\t删除成功\n"); &#125; else &#123; return; &#125; &#125;&#125;//交换void Swap(pPeoInfo *a, pPeoInfo *b)&#123; pPeoInfo *Tmp; Tmp = *a; *a = *b; *b = Tmp;&#125;//修改联系人void ModifyContact(pContact pc)&#123; int modify = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; modify = SearchContact(pc); if (modify != -1) &#123; int n = 0; printf("\t\t\t确认修改？1.yes 2.no:&gt;"); printf("\t\t\t"); scanf("%d", &amp;n); if (1 == n) &#123; printf("\t\t\t请输入姓名:&gt;"); scanf("%s", pc-&gt;data[modify].Name); printf("\t\t\t请输入性别:&gt;"); scanf("%s", pc-&gt;data[modify].Sex); printf("\t\t\t请输入年龄:&gt;"); scanf("%d", &amp;pc-&gt;data[modify].age); printf("\t\t\t请输入电话号:&gt;"); scanf("%s", pc-&gt;data[modify].Tel); printf("\t\t\t请输入地址:&gt;"); scanf("%s", pc-&gt;data[modify].Addr); printf("\t\t\t修改成功\n"); &#125; else &#123; return; &#125; &#125;&#125;//按姓排序void SortContact(pContact pc)&#123; int i = 0; int j = 0; int flag = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; // 冒泡次数 for (i = 0; i &lt; pc-&gt;size - 1; i++) &#123; //冒泡排序 for (j = 0; j &lt; pc-&gt;size - i - 1; j++) &#123; if (strcmp(pc-&gt;data[j].Name, pc-&gt;data[j + 1].Name)&gt;0) &#123; Swap(&amp;pc-&gt;data[j], &amp;pc-&gt;data[j + 1]); flag = 1; &#125; &#125; if (0 == flag) &#123; break; &#125; &#125; printf("排序成功\n");&#125;//列表联系人void ShowContact(pContact pc)&#123; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf("\t\t\t无联系人\n"); return; &#125; printf("\t\t\tName\tSex\tAge\tTel\t\tAddr\n"); for (i = 0; i &lt; pc-&gt;size; i++) &#123; printf("\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n", pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); &#125;&#125;//清空联系人void EmptyContact(pContact pc)&#123; assert(pc); pc-&gt;size = 0; printf("\t\t\t清空成功");&#125;//销毁通讯录void DestoryContact(pContact pc)&#123; assert(pc); free(pc-&gt;data); pc-&gt;data = NULL; pc-&gt;capacity = 0; pc-&gt;size = 0; printf("\t\t\t销毁成功");&#125; test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define _CRT_SECURE_NO_WARNINGS 1#include "contact.h"void meau()&#123; printf("\t\t\t****** 《通讯录》 ********\n"); printf("\t\t\t****************************************\n"); printf("\t\t\t****** 1.添加信息 2.查找信息******\n"); printf("\t\t\t****** 3.删除信息 4.修改信息******\n"); printf("\t\t\t****** 5.按姓排序 6.信息列表******\n"); printf("\t\t\t****** 7.清空信息 0.退出 ******\n"); printf("\t\t\t****************************************\n");&#125;void test()&#123; int input = 0; Contact pc; InitContact(&amp;pc); do &#123; meau(); printf("\t\t\t请选择:&gt;"); scanf("%d", &amp;input); switch (input) &#123; case ADD: AddContact(&amp;pc); break; case SEARCH: SearchContact(&amp;pc); break; case DEIETE: DeleteContact(&amp;pc); break; case MODIFY: ModifyContact(&amp;pc); break; case SORT: SortContact(&amp;pc); break; case SHOW: ShowContact(&amp;pc); break; case EMPTY: EmptyContact(&amp;pc); break; case EXIT: exit(1); break; default: printf("\t\t\t输入有误，请重新输入:&gt;"); break; &#125; &#125; while (input);&#125;int main()&#123; Contact pc; test(); //销毁通讯录 DestoryContact(&amp;pc); system("pause"); return 0;&#125; 结语 今天简单实现了基于静态（动态）顺序表的通讯录，需再努力继续实现链表通讯录。 不忘初心，方得始终！]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>通讯录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找，你真的掌握了吗？]]></title>
    <url>%2F2018%2F05%2F27%2F2018528%2F</url>
    <content type="text"><![CDATA[前言 二分查找，最基本的算法之一，也是面试中常被考察的重点，因为基本的算法最能反映出一个人的基础是否扎实。本文对二分查找相关题目做一个总结。 二分查找函数实现：1234567891011121314151617181920int bin_search(int arr[], int n, int key)&#123; int mid = 0; int low = 0, high = n-1; while (low &lt;= high) &#123; mid = low + (high - low) &gt;&gt; 1; if (arr[mid] == key) &#123; return mid;//找到返回下标 &#125; else if (arr[mid] &lt; key) &#123; low = mid + 1; &#125; else high = mid - 1; &#125; return -1;//找不到返回-1&#125; 题目一 给定一个有序（非降序）数组A，求任意一个i使得A[i]等于key，不存在则返回-1 这个是最原始的二分查找题目，利用数组的有序特性，拆半查找，使得查找时间复杂度为O(logN)。请参考实现代码与注释。12345678910111213141516int search(int arr[], int n, int key) &#123; int low = 0, high = n-1; while(low &lt;= high) &#123; // 注意：若使用(low+high)/2求中间位置容易溢出 int mid = low+((high-low)&gt;&gt;1); if(A[mid] == key) return mid; else if(A[mid] &lt; key) low = mid+1; else // A[mid] &gt; key high = mid-1; &#125; return -1; &#125; 题目二 给定一个有序（非降序）数组A，可含有重复元素，求最小的i使得A[i]等于key，不存在则返回-1 此题也就是求key在数组中第一次出现的位置。这里可能会有人想先直接用原始的二分查找，如果不存在直接返回-1，如果存在，然后再顺序找到这个等于key值区间的最左位置，这样的话，最坏情况下的复杂度就是O（n）了，没有完全发挥出二分查找的优势。这里的解法具体过程请参考实现代码与注释。1234567891011121314151617181920212223int searchFirstPos(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &lt; key) low = mid+1; else // A[mid] &gt;= key high = mid; &#125; /* 循环过程中，当low大于0时，A[low-1]是小于key的，因为A[mid] &lt; key时， low=mid+1；当high小于n-1时，A[high]是大于等于key的，因为A[mid] &gt;= key时， high = mid；循环结束时，low 等于 high，所以，如果A[low](A[high])等于key， 那么low(high)就是key出现的最小位置，否则key在数组中不存在。 */ if(A[low] != key) return -1; else return low; &#125; 题目三 给定一个有序（非降序）数组A，可含有重复元素，求最大的i使得A[i]等于key，不存在则返回-1 此题也就是求key在数组中最后一次出现的位置。与上一题基本一样，但是有个地方要注意，具体请参考实现代码与注释。12345678910111213141516171819202122232425262728int searchLastPos(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; /* 这里中间位置的计算就不能用low+((high-low)&gt;&gt;1)了，因为当low+1等于high 且A[low] &lt;= key时，会死循环；所以这里要使用low+((high-low+1)&gt;&gt;1)， 这样能够保证循环会正常结束。 */ int mid = low+((high-low+1)&gt;&gt;1); if(A[mid] &gt; key) high = mid-1; else // A[mid] &lt;= key low = mid; &#125; /* 循环过程中，当high小于n-1时，A[high+1]是大于key的，因为A[mid] &gt; key时， high=mid-1；当low大于0时，A[low]是小于等于key的，因为A[mid] &lt;= key时， low = mid；循环结束时，low 等于 high，所以，如果A[high](A[low])等于key， 那么high(low)就是key出现的最大位置，否则key在数组中不存在。 */ if(A[high] != key) return -1; else return high; &#125; 题目四 给定一个有序（非降序）数组A，可含有重复元素，求最大的i使得A[i]小于key，不存在则返回-1 也就是求小于key的最大元素的位置。请参考实现代码与注释。1234567891011121314151617181920int searchLastPosLessThan(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low+1)&gt;&gt;1); // 注意，不要导致死循环 if(A[mid] &lt; key) low = mid; else // A[mid] &gt;= key high = mid-1; &#125; /* 循环过程中，当low大于0时，A[low]是小于key的，因为A[mid] &lt; key时， low=mid；当high小于n-1时，A[high+1]是大于等于key的，因为A[mid] &gt;= key时， high = mid-1；循环结束时，low 等于 high，所以，如果A[low](A[high])小于key， 那么low(high)就是要找的位置，否则不存在这样的位置（A[0] &gt;= key时）。 */ return A[low] &lt; key ? low : -1; &#125; 题目五 给定一个有序（非降序）数组A，可含有重复元素，求最小的i使得A[i]大于key，不存在则返回-1。 也就是求大于key的最小元素的位置。请参考实现代码与注释。1234567891011121314151617181920int searchFirstPosGreaterThan(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &gt; key) high = mid; else // A[mid] &lt;= key low = mid+1; &#125; /* 循环过程中，当low大于0时，A[low-1]是小于等于key的，因为A[mid] &lt;= key时， low=mid+1；当high小于n-1时，A[high]是大于key的，因为A[mid] &gt; key时， high = mid；循环结束时，low 等于 high，所以，如果A[high](A[low])大于key， 那么high(low)就是要找的位置，否则不存在这样的位置（A[n-1] &lt;= key时）。 */ return A[high] &gt; key ? high : -1; &#125; 题目六 给定一个有序（非降序）数组A，可含有重复元素，求key在数组中出现的次数 求出第一次出现位置和最后一次出现位置。由于前面都已实现，这里不多解释。请参考实现代码与注释12345678int count(int arr[], int n, int key) &#123; int firstPos = searchFirstPos(A, n, key); // 第一次出现位置 if(firstPos == -1) return 0; int lastPos = searchLastPos(A, n, key); // 最后一次出现位置 return lastPos-firstPos+1; // 出现次数 &#125; 题目七 给定一个有序（非降序）数组A，若key在数组中出现，返回位置，若不存在，返回它应该插入的位置 如 [1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0123456789101112131415161718192021int searchInsert(int arr[], int n, int key) &#123; // 如果比最大值还大，那插入位置就是位置n if(A[n-1] &lt; key) return n; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &gt;= key) high = mid; else // A[mid] &lt; key low = mid+1; &#125; /* 循环过程中，当low大于0时，A[low-1]是小于key的，因为A[mid] &lt; key时， low=mid+1；当high小于n-1时，A[high]是大于等于key的，因为A[mid] &gt;= key时， high = mid；循环结束时，low 等于 high，所以，如果A[low](A[high])等于key， 那么low(high)就是key出现的位置，否则low就是key在数组中应该插入的位置。 */ return high; &#125; 题目八 给定一个有序（非降序）数组A，可含有重复元素，求绝对值最小的元素的位置 找第一个大于等于0的位置，然后和前一个元素的绝对值比较，返回绝对值较小的元素的位置。请参考实现代码与注释1234567891011121314151617int searchMinAbs(int arr[], int n) &#123; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &lt; 0) low = mid+1; else // A[mid] &gt;= 0 high = mid; &#125; /* 循环结束时，如果low != n-1，A[low] &gt;= 0，如果low&gt;0，A[low-1] &lt; 0 */ if(low &gt; 0 &amp;&amp; abs(A[low-1]) &lt; abs(A[low])) return low-1; else return low; &#125; 题目九 给定一个有序（非降序）数组A和一个有序（非降序）数组B，可含有重复元素，求两个数组合并结果中的第k(k&gt;=0)个数字 这个题目出现了两个数组，有序的，不管怎样我们就应该首先考虑二分查找是否可行。若使用顺序查找，时间复杂度最低为O(k)，就是类似归并排序中的归并过程。使用用二分查找时间复杂度为O(logM+logN)。二分查找的具体实现过程请参考实现代码与注释。12345678910111213141516171819202122232425262728293031323334353637383940414243int findKthIn2SortedArrays(int arr[], int m, int B[], int n, int k) &#123; if(m &lt;= 0) // 数组A中没有元素，直接在B中找第k个元素 return B[k]; if(n &lt;= 0) // 数组B中没有元素，直接在A中找第k个元素 return A[k]; int i = (m-1)&gt;&gt;1; // 数组A的中间位置 int j = (n-1)&gt;&gt;1; // 数组B的中间位置 if(A[i] &lt;= B[j]) // 数组A的中间元素小于等于数组B的中间元素 &#123; /* 设x为数组A和数组B中小于B[j]的元素数目，则i+1+j+1小于等于x， 因为A[i+1]到A[m-1]中还可能存在小于等于B[j]的元素； 如果k小于i+1+j+1，那么要查找的第k个元素肯定小于等于B[j]， 因为x大于等于i+1+j+1；既然第k个元素小于等于B[j]，那么只 需要在A[0]~A[m-1]和B[0]~B[j]中查找第k个元素即可，递归调用下去。 */ if(k &lt; i+1+j+1) &#123; if(j &gt; 0) return findKthIn2SortedArrays(A, m, B, j+1, k); else // j == 0时特殊处理，防止死循环 &#123; if(k == 0) return min(A[0], B[0]); if(k == m) return max(A[m-1], B[0]); return A[k] &lt; B[0] ? A[k] : max(A[k-1], B[0]); &#125; &#125; /* 设y为数组A和数组B中小于于等于A[i]的元素数目，则i+1+j+1大于等于y； 如果k大于等于i+1+j+1，那么要查找到第k个元素肯定大于A[i]，因为 i+1+j+1大于等于y；既然第k个元素大于A[i]，那么只需要在A[i+1]~A[m-1] 和B[0]~B[n-1]中查找第k-i-1个元素，递归调用下去。 */ else return findKthIn2SortedArrays(A+i+1, m-i-1, B, n, k-i-1); &#125; // 如果数组A的中间元素大于数组B的中间元素，那么交换数组A和B，重新调用即可 else return findKthIn2SortedArrays(B, n, A, m, k); &#125; 题目十 一个有序（升序）数组，没有重复元素，在某一个位置发生了旋转后，求key在变化后的数组中出现的位置，不存在则返回-1 如 0 1 2 4 5 6 7 可能变成 4 5 6 7 0 1 2.我们先比较中间元素是否是目标值，如果是返回位置。如果不是，我们就应该想办法将搜索区间减少一半。因为存在旋转变化，所以我们要多做一些判断。我们知道因为只有一次旋转变化，所以中间元素两边的子数组肯定有一个是有序的，那么我们可以判断key是不是在这个有序的子数组中，从而决定是搜索这个子数组还是搜索另一个子数组。具体请参考实现代码与注释。 123456789101112131415161718192021222324252627int searchInRotatedArray(int arr[], int n, int key) &#123; int low = 0, high = n-1; while(low &lt;= high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] == key) return mid; if(A[mid] &gt;= A[low]) &#123; // low ~ mid 是升序的 if(key &gt;= A[low] &amp;&amp; key &lt; A[mid]) high = mid-1; else low = mid+1; &#125; else &#123; // mid ~ high 是升序的 if(key &gt; A[mid] &amp;&amp; key &lt;= A[high]) low = mid+1; else high = mid-1; &#125; &#125; return -1; &#125; 如果这样的数组中存在重复元素，还能使用二分吗？答案是不能。请看几个栗子：[1, 2, 2, 2, 2], [2, 1, 2, 2, 2], [2, 2, 1, 2, 2], [2, 2, 2, 1, 2], [2, 2, 2, 2, 1]这些都是有第一个数组旋转一次变化来的，我们不能通过二分确定是否存在元素1. 题目十一 一个有序（升序）数组，没有重复元素，在某一个位置发生了旋转后，求最小值所在位置 如果中间元素小于左端元素，则最小值在左半区间内（包含中间元素）；如果中间元素大于右端元素，则最小值在右半区间内（包含中间元素）。请参考实现代码与注释。123456789101112131415int searchMinInRotatedArray(int arr[], int n) &#123; if(n == 1) return 0; int low = 0, high = n-1; while(low &lt; high-1) // 保证mid != low且mid != high &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &lt; A[low]) // 最小值在low~mid high = mid; else // A[mid] &gt; A[low], // 最小值在mid和high之间 low = mid; &#125; return A[low] &lt; A[low+1] ? low : low+1; &#125; 题目十二 一个有序（升序）数组，没有重复元素，在某一个位置发生了旋转后，求第k(k &gt; 0)小元素的位置 我们可以利用上一题的解答，求出最小值所在位置后，便可以求出第k小元素。请参考实现代码与注释 12345int searchKthInRotatedArray(int arr[], int n, int k) &#123; int posMin = searchMinInRotatedArray(A, n); return (posMin+k-1)%n; &#125; 题目十三 查找数组中第一个比k大的数的下标 当low和high都是非负数时，使用 mid = low + (high - low) / 2;这种形式可以避免溢出。当low和high一个为负另一个为非负时，用mid = (low + high) / 2;这种形式可以避免溢出。 1234567891011121314151617181920int searrrch_first_larger_k(int arr[], int length, int key) &#123; if (arr == nullptr || length &lt;= 0 || arr[length - 1] &lt;= key) return -1; int res = length - 1,low=0,high=length-1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (arr[mid] &gt; key) &#123; res = mid; high = mid - 1; &#125; else// if (arr[mid] &lt;= key) low = mid + 1; &#125; return res; &#125; 结语 二分查找是个普遍考查点，只要深入了解某几个点就可以对二分查找运用自如。]]></content>
      <categories>
        <category>算法境界</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言】经典小游戏-三子棋]]></title>
    <url>%2F2018%2F05%2F26%2F2018527%2F</url>
    <content type="text"><![CDATA[前言 要实现三子棋，首先思考三子棋怎么样实现的，如一下几点： 实现三子棋，在一个3*3的二维数组下把二维数组都初始化为 ‘ *’ 电脑随机生成坐标，判断该坐标是否合法，合法赋值为 ‘0’ 玩家输入合法坐标，该坐标赋值为 ‘X’ 判断输赢，每一行，每一列，或者对角线上的值相等，则为赢。如果棋盘满了，还没有赢家，则为平局！返回 ‘Q’ 项目效果展示： 参考代码：game.h1234567891011121314151617181920212223242526272829303132333435363738/********************************************************** 程序名称：三子棋 ** 编译环境：vs2013 ** 编辑日期：2018.5.26 ** ------by Hunter ***********************************************************/#ifndef __GAME_H__#define __GAME_H__#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;typedef unsigned int uint;enum APP&#123; EXIT, START&#125;;#define ROW 3#define COL 3 //初始化棋盘void InitBoard(char board[ROW][COL], int row, int col);//打印棋盘void PrintBoard(char board[ROW][COL], int row, int col);//电脑走void ComputerMove(char board[ROW][COL], int row, int col);//玩家走void PlayerMove(char board[ROW][COL], int row, int col);//判输赢char is_win(char board[ROW][COL], int row, int col);#endif //__GAME_H__ game.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#define _CRT_SECURE_NO_WARNINGS 1#include"game.h"void InitBoard(char board[ROW][COL], int row, int col)&#123; memset(board, ' ', sizeof(char)* row*col);&#125;//memset函数用来对一段内存空间全部设置为某个字符void PrintBoard(char board[ROW][COL], int row, int col)&#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; printf(" %c | %c | %c \n", board[i][0], board[i][1], board[i][2]); if (i != 2) &#123; printf("---|---|---\n"); &#125; &#125;&#125;void PlayerMove(char board[ROW][COL], int row, int col)&#123; int x = 0; int y = 0; printf("请输入落子的坐标：\n"); while (1) &#123; scanf("%d%d", &amp;x, &amp;y); //保证输入坐标的合法性,玩家输入的坐标是从1开始的 if (((x &gt;= 1) &amp;&amp; (x &lt;= row)) &amp;&amp; ((y &gt;= 1) &amp;&amp; (y &lt;= col))) &#123; if (board[x - 1][y - 1] == ' ') &#123; board[x - 1][y - 1] = 'X';//玩家落子 break; &#125; else &#123; printf("该坐标已被占用，请换一个坐标：\n"); &#125; &#125; else &#123; printf("输入坐标不合法，请重新输入：\n"); &#125; &#125;&#125;void ComputerMove(char board[ROW][COL], int row, int col)&#123; int x = 0; int y = 0; while (1) &#123; x = rand() % row; y = rand() % col;//利用rand函数生成随机坐标 if (board[x][y] == ' ') &#123; board[x][y] = '0'; break; &#125; &#125;&#125;static int is_full(char board[ROW][COL], int row, int col)//函数is_full只在is_win中被调用，可以加上static改变其链接属性&#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; if (board[i][j] == ' ') return 0; &#125; &#125; return 1;&#125;//判断棋盘是否下满了char is_win(char board[ROW][COL], int row, int col)&#123; int i = 0; int j = 0; for (i = 0; i &lt; row; i++) &#123; if ((board[i][0] == board[i][1]) &amp;&amp; (board[i][1] == board[i][2]) &amp;&amp; (board[i][2] != ' ')) &#123; return board[i][1]; &#125; &#125; for (j = 0; j &lt; col; j++) &#123; if ((board[0][j] == board[1][j]) &amp;&amp; (board[1][j] == board[2][j]) &amp;&amp; (board[2][j] != ' ')) &#123; return board[1][j]; &#125; &#125; if ((board[0][0] == board[1][1]) &amp;&amp; (board[1][1] == board[2][2]) &amp;&amp; (board[2][2] != ' ')) &#123; return board[1][1]; &#125; else if ((board[0][2] == board[1][1]) &amp;&amp; (board[1][1] == board[2][0]) &amp;&amp; (board[1][1] != ' ')) &#123; return board[1][1]; &#125; else if (is_full(board, ROW, COL) == 1) &#123; return 'Q';//表示棋盘下满了 &#125; else return ' ';&#125; test.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define _CRT_SECURE_NO_WARNINGS 1#include"game.h"void menu()&#123; printf("***** 《三子棋游戏》*****\n"); printf("****** 1.play *******\n"); printf("****** 0.exit *******\n"); printf("*************************\n"); printf("*************************\n");&#125;void game()&#123; char ret; char board[ROW][COL]; InitBoard(board, ROW, COL); PrintBoard(board, ROW, COL); while (1) &#123; printf("玩家走：\n"); PlayerMove(board, ROW, COL); PrintBoard(board, ROW, COL); ret = is_win(board, ROW, COL); if (ret != ' ') break; printf("电脑走：\n"); ComputerMove(board, ROW, COL); PrintBoard(board, ROW, COL); ret = is_win(board, ROW, COL); if (ret != ' ') break; &#125; if (ret == 'X') &#123; printf(" 你赢了！\n"); &#125; else if (ret == '0') &#123; printf(" 你输了\n"); &#125; else if (ret == 'Q') &#123; printf("平局\n"); &#125;&#125;void test()&#123; int input = 0; srand((uint)time(NULL)); do &#123; menu(); printf("请选择:"); scanf("%d", &amp;input); switch (input) &#123; case START: game(); break; case EXIT: break; default: break; &#125; &#125; while (input);&#125;int main()&#123; test(); system("pause"); return 0;&#125; 结语 天天编程，天天向上！]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>三子棋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数调用过程（栈桢）]]></title>
    <url>%2F2018%2F05%2F25%2F2018526%2F</url>
    <content type="text"><![CDATA[前言 栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构。C语言中，每个栈帧对应着一个未运行完的函数。从逻辑上讲，栈帧就是一个函数执行的环境：函数调用框架、函数参数、函数的局部变量、函数执行完后返回到哪里等等。栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）。 Add()函数调用深度剖析 我们以Add（）函数为例深入的研究一下函数的调用过程。先看一段简单的代码： 123456789101112131415#include &lt;stdio.h&gt;int Add(int x, int y)&#123; int z = 0; z = x + y; return z;&#125;int main()&#123; int a = 10; int b = 20; int ret = Add(a, b) ; printf("ret = %d\n", ret) ; return 0;&#125; 当开始剖析程序调试的时候， 查看【调用堆栈】（按F10进入调试-&gt;窗口-&gt;调用堆栈，或快捷键ctrl+alt+C），用VS2013调试 如下图： 我们发现其实main函数在 tmai nCRTStartup 函数中调用的，而 tmai nCRTStartup 函数是在 mai nCRTStartup 被调用的。我们知道每一次函数调用都是一个过程。这个过程我们通常称之为： 函数的调用过程。这个过程要为函数开辟栈空间（运行时堆栈）， 用于本次函数的调用中临时变量的保存、 现场保护。 这块栈空间我们称之为函数栈帧。所以函数调用过程实际上就是函数栈桢创建与销毁。 而栈帧的维护我们必须了解ebp和esp两个寄存器。 在函数调用的过程中这两个寄存器存放了维护这个栈的栈底和栈顶指针。比如：调用main函数， 我们为main函数分配栈帧空间， 那么栈帧维护如下： ebp存放了指向函数栈帧栈底的地址。esp存放了指向函数栈帧栈顶的地址。 注意：ebp指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。严格说来，“栈帧底部”和“栈底”是不同的概念;esp所指的栈帧顶部和系统栈的顶部是同一个位置。 1 . main函数开始。 要展开main函数的调用就得为main函数创建栈帧， 那我们先来看main函数栈帧的创建。转到反汇编可以更清晰的看到过程： 过程分析： 首先mainCRTStartup()，__mainCRTStartup()函数的调用，调main()函数； 将ebp压栈处理，保存指向栈底的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置； 将esp的值赋给ebp，产生新的ebp； 给esp减去一个16进制数0E4H（为main函数预开辟空间）； push ebx、esi、edi； lea指令，加载有效地址； 初始化预开辟的空间为0xcccccccc； 创建变量a与b。 2. 接下来Add函数的调用。 参数传递过程：(从右到左传参) 过程分析： 将b存入寄存器eax,对b进行实例化_b ; 将a存入寄存器ecx,对a进行实例化_a ; call指令的调用，先要压栈call指令下一条指令的地址，然后跳转到Add()函数的地方。 执行call指令的时候按F11 ， 来到了这里。 再按F11 就进入Add函数的执行代码处。Add函数栈帧的创建： 过程分析： 首先将main()函数ebp压栈处理，保存指向main()函数栈帧底部的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置； 将esp的值赋给ebp，产生新的ebp，即Add()函数栈帧的ebp；给esp减去一个16进制数0E4H（为Add()函数预开辟空间）； push ebx、esi、edi； lea指令，加载有效地址； 初始化预开辟的空间为0xcccccccc； 创建变量z； 获取形参的a和b再相加，将结果存储到z中； 将结果存储到eax寄存器，通过寄存器带回函数的返回值。 剩下的就是是函数返回部分： 过程分析： pop 3次，edi、esi、ebx依次出栈,esp 向下移动； 将ebp赋给esp，使esp指向ebp指向的地方; ebp 出栈，将出栈的内容给ebp（即main()函数ebp），回到main()函数的栈帧； ret 指令，出栈一次，并将出栈的内容当做地址，并跳转到该地址处 。 注： 栈帧这部分内容在不同的编译器上实现存在差异， 但是思想都是一致的。 对于函数调用具体过程剖析完了，我们来个小测验： 在VC6.0环境中， 下面代码的结果是什么？ 1234567891011121314#include &lt;stdio.h&gt;void fun()&#123; int tmp = 10; int *p = (int *)(*(&amp;tmp + 1)); *(p - 1) = 20;&#125;int main() &#123; int a = 0; fun(); printf("a = %d\n", a); return 0;&#125; 事实上在不同平台下这段代码有不同的输出，可自行验证。 此处提供VS编译器答案：20 结语堆和栈的关系 我们平时说的堆栈其实是指栈，而实际上堆和栈是两种不同的内存分配。简单罗列如下各方面的异同点。 堆需要用户在程序中显式申请，栈不用，由系统自动完成。申请/释放堆内存的API，在C中是malloc/free，在C++中是new/delete。申请与释放一定要配对使用，否则会造成内存泄漏(memory leak)，久而久之系统就无内存可用了，出现OOM（Out Of Memory）错误。一般在return/exit或break/continue等语句时容易忘记释放内存，所以检查内存泄漏的代码时要关注这些语句，看它们前面是否有必要的释放语句free/delete。 堆的空间比较大，栈比较小。所以申请大的内存一般在堆中申请；栈上不要有较大的内存使用，比如大的静态数组；而且除非算法必要，否则一般不要使用较深的迭代函数调用，那样栈消耗内存会随着迭代次数的增加飞涨。 关于生命周期。栈较短，随着函数退出或返回，本函数的栈就完成了使用；堆就要看什么时候释放，生命周期就什么时候结束。 关于函数调用即栈桢创建与销毁就浅析到此！]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>栈桢</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平均数三种境界]]></title>
    <url>%2F2018%2F05%2F24%2F2018524%2F</url>
    <content type="text"><![CDATA[前言 平均数:平均数是指在一组数据中所有数据之和再除以数据的个数。平均数是表示一组数据集中趋势的量数，它是反映数据集中趋势的一项指标。今天就简单讲解一下编程界平均数几种简要解法。 解法一： 这种方法最为简单，弊端是如果a和b非常大的话，a+b的值可能超过了整型的储存范围（最大值为2147483647），导致溢出，得到错误的结果。 参考代码 123456789101112131415161718#include &lt;stdio.h&gt; int main() &#123; int a=10; int b=20; int avg=0; avg=(a+b)/2;//平局值 //或者 avg=(a+b)&gt;&gt;1://右移表示除2，左移表示乘2。 //【-1除外】（右移一位为-1，左移一位为-2） printf("%d\n",avg); return 0; &#125; 解法二： 用一个较大值减去另一个较小值得到二者之差，将差除2后加上较小值即得到了二者平均值，可有效防止溢出的情况的出现。 步骤如图： 参考代码 123456789101112131415161718#include &lt;stdio.h&gt; int main() &#123; int a=10; int b=20; int avg=0; avg=b+(a-b)/2;//平均值 //或者 avg=b+(a-b)&gt;&gt;1://右移表示除2，左移表示乘2 //【-1除外】（右移一位为-1，左移一位为-2） printf("%d\n",avg); return 0; &#125; 方法三： 将两个数的二进制位分为相同部分和不同部分，利用按位与求出相同部分的平均数，然后再用按位异或求出不同部分的平均数，加起来就是两个数的平均数。 这里举个栗子： a = 10,b = 12; 10&amp;12可得到 1000 10^12可得到 0110计算a与b的平均值C语言表达式: avg = (a&amp;b) + (a^b)&gt;&gt;1 参考代码 12345678910111213141516#include &lt;stdio.h&gt; int main() &#123; int a=10; int b=20; int avg=0; avg = (a&amp;b) + (a^b)&gt;&gt;1; //或者 avg = (a&amp;b) + (a^b)/2; printf("%d\n",avg); return 0; &#125; 结语 知识在于汇总，方法在于总结。不忘初心，励志前行！]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>平均数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++代码规范]]></title>
    <url>%2F2018%2F05%2F23%2F2018525%2F</url>
    <content type="text"><![CDATA[前言 本文摘录自谷歌开源项目开源指南。 详见 —&gt;谷歌开源项目开源指南 头文件 每通常一个 .c/.cpp文件都有一个对应的 .h 文件。也有一些常见例外，如单元测试代码和只包含 main() 函数的 .c/.cpp文件。正确使用头文件可令代码在可读性，文件大小和性能上大为改观。 下面的规则将引导你规避使用头文件时的各种陷阱。 自包含的头文件 头文件应该能够自给自足（自包含的，也就是可以作为第一个头文件被引入），以 .h 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以以应 .inc 结尾不允许。出分离 -inl.h 头文件的做法。所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 1.2。#define保护，统计包含它所需要的其它头文件，也不要求定义任何特别的符号。 不过有一个例外，即一个文件并不是自足的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（特定于平台）扩展部分，这些文件就要用 .inc 文件扩展名。 如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。有用凡是到这些的 .cpp 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 -inl.h 文件里（译者注：过去该规范曾提倡把定义放到-inl.h里过）。 有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，它就那么定义只能在实例化该模板的 .cpp 文件里。 #define保护 所有头文件都应该使用 #define 来防止头文件被多重包含，命名格式当是： _H_ 。为保证唯一性，头文件的命名应该基于所有项目源代码树的全路径。例如，项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护： #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ … #endif // FOO_BAR_BAZ_H_ 前置声明 尽可能地避免使用前置声明。使用 #include 所有游戏需要的头文件即可。定义：所谓「前置声明」（forward declaration）是类，函数和模板的纯粹声明，没伴随着其定义。 优点： 前置声明能够节省编译时间，的多余 #include 会迫使compile-器展开更多的文件，处理更多的输入。前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。例如扩大形参类型，加个自带默认参数的模板形参等等。前置声明来自命名空间 std:: 的符号时，其行为未定义。很难判断什么时候该用前置声明，时候什么用该 #include 极端情况下，用前置声明代替。 includes 甚至都会暗暗地改变代码的含义： // bh：struct B {};struct D ： B {} // good_user.cpp：＃包括 “BH”void f （B ）;void f （void ）;void test （D * x ） { f （x ）; } //调用f（B ）如果 #include 被 B 状语从句： D 的前置声明替代， test() 就会调用 f(void) 。前置声明了include 不少来自头文件的符号时，就会比单单一行的 冗长。仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。 结论： 尽量避免前置声明那些定义在其他项目中的实体。 函数：总是使用 #include。 类模板：优先使用 #include。 至于什么时候包含头文件，参见 1.5。#include的路径及顺序 。 内联函数 只有当函数只有10行甚至更少时才将其定义为内联函数。定义：当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。 优点： 只要内联的函数体小小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性​​能关键的函数，鼓励使用内联。 缺点： 滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。 结论： 一个较为合理的经验准则是，不要内联超过10行的函数。谨谨对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用！ 另一个实用的经验准则：内联那些包含循环或 switch 语句的函数常常是得不偿失（除非在大多数情况下，这些循环或 switch 语句从不被执行）。 有些函数即使声明为内联的也不一定会被编译器内联，这点很重要; 比如虚函数和递归函数就不会被正常内联。通常，递归函数不应该声明成内联函数。（YuleFox注：递归调用堆栈的展开并不像循环那么简单，比如递进层数在编译时可能是未知的，大多数编译器都不支持内联递归函数）。虚函数内联的主要原因是想把它的函数体放在类定义内，为了图个方便，抑或是当作文件描述其行为，比如精短的存取函数。 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：相关头文件，C库，C ++库，其他库的 .h，本项目内的 .h。项目内部文件应按照项目源代码目录树结构排列，避免使用UNIX特殊的快捷目录 .（当前目录）或 .. （上级目录）。 例如， google-awesome-project/src/base/logging.h 应该按如下方式包含：#include “base / logging.h”又如， dir/foo.cpp 或 dir/foo_test.cpp 的主要作用英文的英文实现或测试 dir2/foo2.h 的功能， foo.cpp 中包含头文件的次序如下：dir2/foo2.h （优先位置，详情如下）C系统文件C ++系统文件库其他的 .h 文件项目本。内 .h 文件优先这种顺序的排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cpp 或 dir/foo_test.cpp 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。 dir/foo.cpp 和 dir2/foo2.h 通常位于同一目录下(如base/basictypes_unittest.cpp 和 base/basictypes.h），但也可放在不同目录下。按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。 您所依赖的符号（符号）被哪些头文件所定义，您就应该包含（包括）哪些头文件，前置声明 （向前声明）情况除外。您比如要用到 bar.h 中的某个符号，哪怕您所包含的 foo.h 已经包含了 bar.h，也照样得包含 bar.h，除非foo.h 有明确 说明它会自动向您提供 bar.h 中符号。不过，凡是cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其cc文件里面了，就像 foo.cpp 只包含 foo.h就够了，不用再管后者所包含的其它内容。 函数参数顺序 总述:函数的参数顺序为：输入参数在先，后跟输出参数。 说明 C / C ++中的函数参数或者是函数的输入，或者是函数的输出，或兼而有之。输入参数通常是值参或 const 引用，输出参数或输入/输出参数则一般为非 const 指针。在排列参数顺序时，将所有的输入参数置于输出参数之前。特别要注意，在加入新参数时不要因为它们是新参数就置于参数列表最后，而是仍然要按照前述的规则，即将新的输入参数也置于输出参数之前。 这并非一个硬性规定。输入/输出参数（通常是类或结构体）让这个问题变得复杂。并且，有时候为了其他函数保持一致，你可能不得不不所有变通。 编写简短函数 总述:我们倾向于编写简短，凝练的函数。 说明 我们承认长函数有时是合理的，因此并不硬限制函数的长度。如果函数超过40行，可以思索一下能不能在不影响程序结构的前提下对其进行分割。 即使一个长函数现在工作的非常好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的错误。使函数尽量简短，以便于他在他人阅读和修改代码。 在处理代码时，你可能会发现复杂的长函数。不要害怕修改现有代码：如果证实这些代码使用/调试起来很困难，或者你只需​​要使用其中的一小段代码，考虑将其分割为更加简短并易于管理的若干函数。 引用参数 总述:所有按引用传递的参数必须加上 const。 说明 》在C语言中，如果函数需要修改变量的值，参数必须为指针，如 。在C ++中，函数还可以声明为引用参数： 。int foo(int *pval)int foo(int &amp;val) 优点 引用定义参数可以防止出现 (*pval)++ 这样丑陋的代码。引用参数对于拷贝构造函数这样的应用也是必需的。同时也更明确地不接受空指针。 缺点 容易引起误解，因为引用在语法上是值变量却拥有指针的语义。 结论 函数参数列表中，所有引用参数都必须是 const：void Foo （const string ＆in ， string * out ）;事实上这在Google Code是一个硬性约定：输入参数是值参或 const 引用，输出参数为指针。输入参数可以是 const 指针，但决不能是非 const 引用参数，除非特殊要求，比如 swap()。有时候，在输入形参中用针指更明智。 比如：const Tconst T&amp;可能会传递空指针。函数要把指针或对地址的引用赋值给输入形参。总而言之，大多时候输入形参往往是 。用若 则说明输入侧另有处理。所以若要使用 ，则应给出相应的理由，否则会使读者感到迷惑。const T&amp;const Tconst T* 函数重载总述 》若要使用函数重载，则必须能让读者一看调用点就胸有成竹，而不用花心思猜测调用的重载函数到底是哪一种。这一规则也适用于构造函数。 定义 你可以编写一个参数类型的函数，然后用另一个参数类型函数对其进行重载： 12345const string&amp;const char* class MyClass &#123; public ： void Analyze （const string ＆text ）; void 分析（const char * text ， size_t textlen ）;&#125;; 优点 通过重载参数不同的同名函数，可以令代码更直观。模板化代码需要重载，这同时也能为使用者带来便利。 缺点 如果函数单靠不同的参数类型而重载（acgtyrant注：这意味着参数数量不变），读者就得十分熟悉C ++五花八门的匹配规则，以了解匹配过程具体到底如何。另外，如果派生类只重载了某个函数的部分变体，继承语义就容易令人困惑。 结论 如果打算重载一个函数，可以试试改在函数名里加参数信息。例如，用 AppendString()和 AppendInt() 等，而不是一口气重载多个 Append()。如果重载函数的目的是为了支持不同数量的同一类型参数，则优先考虑使用 std::vector 以便使用者可以用 列表初始化指定参数。 缺省参数总述 只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致。参数缺省与 函数重载 遵循同样的规则。一般情况下建议使用函数重载，尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下。 优点 有些函数一般情况下使用默认参数，但有时需要又使用非默认的参数。缺省参数为这样的情形提供了便利，使程序员不需要为了极少的例外情况编写大量的函数。和函数重载相比，缺省参数的语法更简洁明了，减少了大量的样板代码，也更好地区别了“必要参数”和“可选参数”。 缺点 缺省参数实际上是函数重载语义的另一种实现方式，因此所有 不应当使用函数重载的理由 也都适用于缺省参数。 虚函数调用的缺省参数取决于目标对象的静态类型，此时无法保证给定函数的所有重载声明的都是同样的缺省参数。 缺省参数是在每个调用点都要进行重新求值的，这会造成生成的代码迅速膨胀。作为读者，一般来说也更希望缺省的参数在声明时就已经被固定了，而不是在每次调用时都可能会有不同的取值。 缺省参数会干扰函数指针，导致函数签名与调用点的签名不一致。而函数重载不会导致这样的问题。 结论 对于虚函数，不允许使用缺省参数，因为在虚函数中缺省参数不一定能正常工作。如果在每个调用点缺省参数的值都有可能不同，在这种情况下缺省函数也不允许使用。（例如，不要写像 这样的代码。）void f(int n = counter++); 在其他情况下，如果缺省参数对可读性的提升远远超过了以上提及的缺点的话，可以使用缺省参数。如果仍有疑惑，就使用函数重载。 函数返回类型后置语法总述 只有在常规写法（返回类型前置）不便于书写或不便于阅读时使用返回类型后置语法。 定义 C ++现在允许两种不同的函数声明方式。以往的写法是将返回类型置于函数名之前。例如： 1int foo （int x ）; C ++ 11引入了这一新的形式。现在可以在函数名前使用 auto 关键字，在参数列表之后后置返回类型。例如： 1auto foo （int x ） - &gt; int ; 后置返回类型为函数作用域。对于像 int 这样简单的类型，两种写法没有区别。但对于复杂的情况，例如类域中的类型声明或者以函数参数的形式书写的类型，写法的不同会造成区别。 优点 后置返回类型是显式地指定 Lambda表达式 的返回值的唯一方式。某些情况下，编译器可以自动推导出Lambda表达式的返回类型，但并不是在所有的情况下都能实现。即使编译器能够自动推导，显式地指定返回类型也能让读者更明了。 有时在已经出现了的函数参数列表之后指定返回类型，能够让书写更简单，也更易读，尤其是在返回类型依赖于模板参数时。例如： 12template &lt; class T ， class U &gt; auto add （T t ， U u ） - &gt; decltype （t + u ）; 对比下面的例子：1template &lt; class T ， class U &gt; decltype （declval &lt; T ＆&gt; （） + declval &lt; U ＆gt ;） add （T t ， U u ）; 缺点 后置返回类型相对来说是非常新的语法，而且在C和Java中都没有相似的写法，因此可能对读者来说比较陌生。在已有的代码中有大量的函数声明，你不可能把它们都用新的语法重写一遍。因此实际的做法只能是使用旧的语法或者新旧混用。在这种情况下，只使用一种版本是相对来说更规整的形式。 结论 在大部分情况下，应当继续使用以往的函数声明写法，即将返回类型置于函数名前。只有在必要的时候（如Lambda表达式）或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法。但是后一种情况一般来说是很少见的，大部分时候都出现在相当复杂的模板代码中，而多数情况下不鼓励写这样 复杂的模板代码。 命名约定 最重要的一致性规则是命名管理。命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义：类型，变量，函数，常量，宏，等等，甚至。我们大脑中的模式匹配引擎非常依赖这些命名规则。 命名规则具有一定随意性，但相比按个人喜好命名，一致性更重要，所以无论你认为它们是否重要，规则总归是规则。 通用命名规则总述 函数命名，变量命名，文件命名要有描述性; 少用缩写。 说明 尽可能使用描述性的命名，别心疼空间，毕竟相比之下让代码易于新读者理解更重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。 123456789int price_count_reader ; //无缩写int num_errors ; //“num”是一个常见的写法int num_dns_connections ; //人人都知道“DNS”是什么int n ; //毫无意义。int nerr ; //含糊不清的缩写。int n_comp_conns ; //含糊不清的缩写。int wgc_connections ; //只有贵团队知道是什么意思int pc_reader ; //“pc”有太多可能的解释了。int cstmr_id ; //删减了若干字母。 注意，一些特定的广为人知的缩写是允许的，例如用 i 表示迭代变量和用 T 表示模板参数。 模板参数的命名应当遵循对应的分类：类型模板参数应当遵循 类型命名 的规则，而非类型模板应当 遵循变量命名 的规则。 文件命名总述 文件名要全部小写，可以包含下划线（_）或连-字符（），依照项目的约定。如果没有约定，那么“ _” 更好。 说明 可接受的文件命名示例： 12345my_useful_class.cppmy-useful-class.cppmyusefulclass.cppmyusefulclass_test.cpp // _unittest状语从句： _regtest 已弃用。 C ++文件要以 .cpp结尾，头文件以 .h 结尾。专门插入文本的文件则以 .inc 结尾，参见 头文件自足。 不要使用已经存在于 /usr/include 下的文件名（Yang.Y注：即编译器搜索系统头文件的路径），如 db.h。 通常应尽量让文件名更加明确。 http_server_logs.h 就比 logs.h 要好。定义类时文件名一般成对出现，如 foo_bar.h 和 foo_bar.cpp，对应于类 FooBar。 联内必须函数放在 .h 文件中。如果内联函数比较短，就直接放在 .h 中。 类型命名总述 类型名称的每个单词首字母均大写，不包含下划线： MyExcitingClass， MyExcitingEnum。 说明 所有类型命名 - 类，结构体，类型定义（typedef），枚举，类型模板参数 - 均使用相同约定，即以大写字母开始，每个单词首字母均大写，不包含下划线。例如： 12345678910111213//类和结构体类 UrlTable &#123; ...class UrlTableTester &#123; ...struct UrlTableProperties &#123; ...//类型定义typedef hash_map &lt; UrlTableProperties * ， string &gt; PropertiesMap ;//使用别名使用 PropertiesMap = hash_map &lt; UrlTableProperties * ， string &gt; ;//枚举enum UrlTableErrors &#123; ... 变量命名总述 变量（包括函数参数）和数据成员名一律小写，单词之间用下划线连接。类的成员变量以下划线结尾，但结构体的就不用，如： a_local_variable， a_struct_data_member， a_class_data_member_。 说明 普通变量命名 举例： 字符串 table_name ; //好 - 用下划线。字符串 表名; //好 - 全小写。字符串 tableName ; //差 - 混合大小写类数据成员 不管是静态的还是非静态的，类数据成员都可以和普通变量一样，但要接下划线。1234567891011121314151617类 TableInfo &#123; ...private ： string table_name_ ; //好 - 后加下划线。 字符串 tablename_ ; //好。 静态 池&lt; TableInfo &gt; * pool_ ; //好。&#125;;结构体变量不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样，不用像类那样接下划线：struct UrlTableProperties &#123; string name ; int num_entries ; 静态 池&lt; UrlTableProperties &gt; * 池;&#125;; 结构体与类的使用讨论，参考 结构体与类。 常量命名总述 声明为 constexpr 或 const 的变量，或在程序运行期间其值始始保持不变的，命名时以“k”开头，大小写混合。例如：1const int kDaysInAWeek = 7 ; 说明 所有具有静态存储类型的变量（例如静态变量或全局变量，参见 存储类型）都应当以此方式命名。对于其他存储类型的变量，如自动变量等，这条规则是可选的。如果不采用这条规则，就按照一般的变量命名规则。 命名空间命名总述 命名空间以小写字母命名。最高级命名空间的名字取决于项目名称。要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突。 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字。命名空间中的代码，应当存放于和命名空间的名字匹配的文件夹或其子文件夹中。 注意 不使用缩写作为名称 的规则同样适用于命名空间。命名空间中的代码极少需要涉及命名空间的名称，因此没有必要在命名空间中使用缩写。 要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突。由于名称查找规则的存在，命名空间之间的冲突完全有可能导致编译失败。尤其是，不要创建嵌套的 std 命名空间。建议使用更独特的项目标识符（websearch::index， websearch::index_util）而非常见的极易发生冲突的名称（比如 websearch::util）。 对于 internal 命名空间，要当心加入到同一 internal 命名空间的代码之间发生冲突（由于内部维护人员通常来自同一团队，因此常有可能导致冲突）。在这种情况下，请使用文件名以使内部名称独一无二（例如对于 frobber.h，使用 websearch::index::frobber_internal）。 枚举命名总述 枚举命名应当状语从句： 常量 或 宏 harmony和谐： kEnumName 或是 ENUM_NAME。 说明 单独枚举值应该优先采用 常量 的命名方式。但 宏 方式的命名也可以接受。枚举名 UrlTableErrors （以及 AlternateUrlTableErrors）是类型，所以要用大小写混合的方式。 1234567891011enum UrlTableErrors &#123; kOK = 0 ， kErrorOutOfMemory ， kErrorMalformedInput ，&#125;;枚举 AlternateUrlTableErrors &#123; OK = 0 ， OUT_OF_MEMORY = 1 ， MALFORMED_INPUT = 2 ，&#125;; 宏命名总述 你并不打算 使用宏，对吧？如果你一定要用，像这样命名： MY_MACRO_THAT_SCARES_SMALL_CHILDREN。 说明 参考 预处理宏 ; 通常 不应该 使用宏。如果不得不使用，其命名像枚举命名一样全部大写，使用下划线： 12#define ROUND（x）...#define PI_ROUNDED 3.0 命名规则的特例总述 如果你命名的实体与已有C / C ++实体相似，可参考现有命名策略。 12345678910bigopen()：函数名，参照 open() 的形式uint： typedefbigpos： struct 或 class，参照 pos 的形式sparse_hash_map：STL型实体; 参照STL命名约定LONGLONG_MAX：常量，如同 INT_MAX 注意 注释虽然写起来很痛苦，但对保证代码可读性至关重要。下面的规则描述了如何注释以及在哪儿注释。当然也要记住：注释固然很重要，但最好的代码应当本身就是文档。有意义的类型名和变量名，要远胜过要用注释解释的含糊不清的名字。 你写的注释是给代码读者看的，也就是下一个需要理解你的代码的人。所以慷慨些吧，下一个读者可能就是你！ 注释风格总述 使用 // 或 /* */ 统一就好。 说明 // 或 /* */ 都可以; 但 //更 常用。要在如何注释及注释风格上确保统一。 文件注释总述 在每一个文件开头加入版权公告。 文件注释描述了该文件的内容。如果一个文件只声明，或实现或测试了一个对象，并且这个对象已经在它的声明处进行了详细的注释，那么就没有必要再加上文件注释。除此之外的其他文件都需要文件注释。 说明 法律公告和作者信息 每个文件都应该包含许可证引用。为项目选择合适的许可证版本（比如，Apache 2.0，BSD，LGPL，GPL） 如果你对原始作者的文件做了重大修改，请考虑删除原作者信息。 文件内容 如果一个 .h 文件声明了多个概念，则文件注释应当对文件的内容做一个大致的说明，同时说明各个概念之间的联系。一个一到两行的文件注释就足够了，对于每个概念的详细文档应当放在各个概念中，而不是文件注释中。 不要在 .h 和 .cpp 之间复制注释，这样的注释偏离了注释的实际意义。 类注释总述 每个类的定义都要附带一份注释，描述类的功能和用法，除非它的功能相当明显。 1234567891011//遍历GargantuanTable的内容。//示例：// GargantuanTableIterator * iter = table-&gt; NewIterator（）;// it for（iter-&gt; Seek（“foo”）;！iter-&gt; done（）; iter-&gt; Next（））&#123;// process（iter-&gt; key（），iter-&gt; value（））;//&#125;//删除它;类 GargantuanTableIterator &#123; ...&#125;; 说明 类注释应当为读者理解如何使用与何时使用类提供足够的信息，同时应当提醒读者在正确使用此类时应当考虑的因素。如果类有任何同步前提，请用文档说明。如果该类的实例可被多线程访问，要特别注意文档说明多线程环境下相关的规则和常量使用。 如果你想用一小段代码演示这个类的基本用法或通常用法，放在类注释里也非常合适。 如果类的声明和定义分开了（例如分别放在了 .h 和 .cpp 文件中），此时，描述类用法的注释应当和接口定义放在一起，描述类的操作和实现的注释应当和实现放在一起。 函数注释总述 函数声明处的注释描述函数功能; 定义处的注释描述函数实现。 说明 函数声明:基本上每个函数声明处前都应当加上注释，描述函数的功能和用途。只有在函数的功能简单而明显时才能省略这些注释（例如，简单的取值和设值函数）。注释使用叙述式（“打开文件”）而非指令式（“打开文件”）; 注释只是为了描述函数，而不是命令函数做什么。通常，注释不会描述函数如何工作。那是函数定义部分的事情。 函数声明处注释的内容： 函数的输入输出。对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数。函数是否分配了必须由调用者释放的空间。参数是否可以为空指针。是否存在函数使用上的性能隐患。如果函数是可重入的，其同步提提是什么？举例如下： //返回此表的迭代器。当迭代器完成时，它是客户端的责任//并且一旦创建迭代器的GargantuanTable对象被删除，它就不能使用迭代器。////迭代器最初位于表的开始位置。////此方法等同于：// Iterator iter = table-&gt; NewIterator（）;// iter-&gt; Seek（“”）;//返回iter;//如果您要立即寻找到返回的迭代器中的其他位置，则使用NewIterator（）会更快，并避免额外的查找。Iterator GetIterator （） const;但也要避免罗罗嗦嗦，或者对显着易见的内容进行说明。下面的注释就没有必要加上“否则返回false”，因为已经暗含其中了：//如果表不能包含更多条目，则返回true。bool IsTableFull （）;注释函数重载时，注释的重点应该是函数中被重载的部分，而不是简单的重复被重载的函数的注释。多数情况下，函数重载不需要额外的文档，因此也没有必要加上注释。 注释构造/析构函数，切记读代码的人知道构造/析构函数的所有功能，所以“销毁这一对象”这样的注释是没有意义的。你应该注意的是注意构造函数对参数做了什么（例如，是否取得指针所有权）以及析构函数清理了什么。如果都是些无关紧要的内容，直接省掉注释。析构函数前没有注释是很正常的。 函数定义 如果函数的实现过程中用到了很巧妙的方式，那么在函数定义处应当加上解释性的注释。例如，你所使用的编程技巧，实现的大致步骤，或解释如此实现的理由。举个例子，你可以说明为什么函数的前半部分要加锁而后半部分不需要。 不要 从 .h 文件或其他地方的函数声明处直接复制注释。简要重述函数功能是可以的，但注释重点要放在如何实现上。 变量注释总述 通常变量名本身足以很好说明变量用途。某些情况下，也需要额外的注释说明。 说明 类数据成员:每个类数据成员（也叫实例变量或成员变量）都应该用注释说明用途。如果有非变量的参数（例如特殊值，数据成员之间的关系，生命周期等）不能够使用类型与变量名明确表达，则应当加上注释。然而，如果变量类型与变量名已经足够描述一个变量，那么就不需要加上注释。 特别地，如果变量可以接受 NULL 或 -1 等警戒值，须加以说明。比如：1234567891011private ：//用于限制检查表访问。-1意味着//我们还不知道表中有多少个条目。int num_total_entries_ ;全局变量和数据成员一样，所有全局变量也要注释说明含义及用途，以及作为全局变量的原因。比如：//在此回归测试中我们经历的测试用例的总数。const int kNumTestCases = 6 ; 实现注释总述 对于代码中巧妙的，晦涩的，有趣的，重要的地方加以注释。 说明 代码前注释:巧妙或复杂的代码段前要加注释。比如： 123456789101112131415161718192021222324252627282930//将结果除以2，考虑到x//包含来自add的进位。for （int i = 0 ; i &lt; result - &gt; size （）; i ++ ） &#123; x = （x &lt;&lt; 8 ） + （* result ）[ i ]; （* 结果）[ i ] = x &gt;&gt; 1 ; x ＆= 1 ;&#125;行注释比较隐晦的地方要在行尾加入注释。在行尾空两格进行注释。比如：//如果我们有足够的内存，也可以对数据部分进行mmap。mmap_budget = max &lt; int64 &gt; （0 ， mmap_budget - index_ - &gt; length （））;if （mmap_budget &gt; = data_size_ &amp;&amp; ！MmapData （mmap_chunk_bytes ， mlock ）） return ; //错误已经记录。注意，这里用了两段注释分别描述这段代码的作用，并提示函数返回错误已经被记入日志。如果你需要连续进行多行注释，可以使之对齐获得更好的可读性：DoSomething （）; //在这里发表评论，以便评论排成一行。DoSomethingElseThatIsLonger （）; //代码和注释之间有两个空格。&#123; //允许打开一个新的作用域时，在注释之前的一个空格 // //因此注释与下面的注释和代码一起排列。 DoSomethingElse （）; //通常在行注释之前有两个空格。&#125;std :: vector &lt; string &gt; list &#123; //支撑列表中的注释描述下一个元素... “First item” ， // ..并且应该适当地对齐。&#125;; 函数参数注释 如果函数参数的意义不明显，考虑用下面的方式进行弥补： 如果参数是一个字面常量，并且这一常量在多处函数调用中被使用，用以推断它们一致，你应该用一个常量名让这个约定变得更明显，并且保证这一约定不会被打破。考虑更改函数的签名，让某个 bool 类型的参数变为 enum 类型，这样可以让这个参数的值表达其意义。如果某个函数有多个配置选项，你可以考虑定义一个类或结构体以保存所有的选项，并传入类或结构体的实例。这样的方法有许多优点，例如这样的选项可以在调用处用变量名引用，这样就能清晰地表明其意义。同时也减少了函数参数的数量，使得函数调用更易读也易写。除此之外，以这样的方式，如果你使用其他的选项，就无需对调用点进行更改。用具名变量代替大段而复杂的嵌套表达式。万不得已时，才考虑在调用点用注释阐明参数的意义。 不允许的行为 不要描述显而易见的现象， 永远不要 用自然语言翻译代码作为注释，除非即使对深入理解C ++的读者来说代码的行为都是不明显的。要假设读代码的人C ++水平比你高，即便他/她可能不知道你的用意. 你所提供的注释应当解释代码 为什么 要这么做和代码的目的，或者最好是让代码自文档化. 标点，拼写和语法总述 注意标点，拼写和语法; 写的好的注释比差的要易读的多。 说明 注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句。大多数情况下，完整的句子比句子片段可读性更高。短一点的注释，比如代码行尾注释，可以随意点，但依然要注意风格的一致性。 虽然被别人指出该用分号时却用了逗号多少有些尴尬，但清晰易读的代码还是很重要的。正确的标点，拼写和语法对此会有很大帮助。 行长度总述 每一行代码字符数不超过80。 我们也认识到这条规则是有争议的，但很多已有代码都遵照这一规则，因此我们感觉一致性更重要。 优点 提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为。很多人同时并排开几个代码窗口，根本没有多余的空间拉伸窗口。大家都把窗口最大尺寸加以限定，并且80列宽是传统标准。那么为什么要改变呢？ 缺点 反对该原则的人则认为更宽的代码行更易阅读。80列的限制是上个世纪60年代的大型机的古板缺陷;现代设备具有更宽的显示屏，可以很轻松地显示更多代码。 结论 80个字符是最大值。 如果无法在不伤害易读性的条件下进行断行，那么注释行可以超过80个字符，这样可以方便复制粘贴。例如，带有命令示例或URL的行可以超过80个字符。长所有游戏的路径 #include 语句可以超出80列。 文件头保护 可以无视该原则。 函数调用总述 要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。 说明 1234567891011121314151617函数调用遵循如下形式：bool retval = DoSomething （argument1 ， argument2 ， argument3 ）;如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格：bool retval = DoSomething （averyveryveryverylongargument1 ， argument2 ， argument3 ）;参数也可以放在次行，缩进四格：如果 （...） &#123; ... ... if （...） &#123; DoSomething （ argument1 ， argument2 ， // 4空格缩进 argument3 ， argument4 ）; &#125; 把多个参数放在同一行以减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。 循环和开关选择语句总述 switch 语句可以使用大括号分段，以表明cases之间不是连在一起的。在单语句循环里，括号可用可不用。循环空应行业释义体育使用 {} 或 continue。 说明 switch 语句中的 case 块可以使用大括号也可以不用，取决于你的个人喜好。如果用的话，要按照下文所述的方法。 如果有不满足 case 条件的枚举值， switch 应该default 总是包含一个 匹配（如果有输入值没有case去处理，编译器将给出警告）。如果 default 应该永远执行不到，简单的加条 assert： 1234567891011121314switch （var ） &#123; case 0 ： &#123; // 2空格缩进 ... // 4空格缩进 break ; &#125; 案例 1 ： &#123; ... break ; &#125; default ： &#123; assert （false ）; &#125;&#125; 在单语句循环里，括号可用可不用：123456789101112131415for （int i = 0 ; i &lt; kSomeNumber ; ++ i ） printf （“我爱你\ n ” ）;for （int i = 0 ; i &lt; kSomeNumber ; ++ i ） &#123; printf （“我拿回来\ n ” ）;&#125;空循环体应使用 &#123;&#125; 或 continue，而不是一个简单的分号。while （condition ） &#123; //反复循环直到条件失效。&#125;for （int i = 0 ; i &lt; kSomeNumber ; ++ i ） &#123;&#125; //可 - 空循环体。同时 （条件） 继续; //可 - contunue表明没有逻辑。while （condition ）; //差 - 看起来仅仅只是while / loop的部分之一。 构造函数初始值列表总述* 构造函数初始化列表放在同一行或按四格缩进并排多行。 说明 下面两种初始值列表方式都可以接受： 1234567891011121314151617181920212223242526//如果所有变量能放在同一行：MyClass :: MyClass （int var ） ： some_var_ （var ） &#123; DoSomething （）;&#125;//如果不能放在同一行，//必须置于冒号后，并缩进4个空格MyClass :: MyClass （int var ） ： some_var_ （var ）， some_other_var_ （var + 1 ） &#123; DoSomething （）;&#125;//如果初始化列表需要置于多行，将每个成员放在单独的一行//并逐行对齐MyClass :: MyClass （int var ） ： some_var_ （var ）， // 4空格缩进 some_other_var_ （var + 1 ） &#123; //列队 DoSomething （）;&#125;//右大括号&#125;可以和左大括号&#123;放在同一行//如果这样做合适的话MyClass :: MyClass （int var ） ： some_var_ （var ） &#123;&#125; 结语 代码规范是项目开发非常重要的一点，作为一名合格的程序猿应该将代码规范熟记于心。]]></content>
      <categories>
        <category>C++知识及题集</category>
      </categories>
      <tags>
        <tag>c/c++代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言】经典小游戏-扫雷]]></title>
    <url>%2F2018%2F05%2F22%2F201855223%2F</url>
    <content type="text"><![CDATA[前言 扫雷，是一个Windows平台下一个经典的小游戏，今有兴趣玩了几把后，就利用所学二维数组的相关知识模拟实现了一个“扫雷游戏”。由于学识浅薄，界面有点简陋，尽请谅解！ 项目思路: 首先想一想扫雷游戏在Windows平台下是如何实现的。 其次通过观察游戏，我们可以想到需要用两个二维数组来实现扫雷的功能。 游戏刚开始，需要需要显示棋盘，用“*”遮盖雷的坐标，所以要有一个填充棋盘的函数。 通过rand()函数，随机生成雷的坐标，埋雷的函数。 每次扫过后，都要显示新的棋盘，显示棋盘的函数。 如果要想第一次踩不到雷的，需要把该坐标下得雷移动到其他不是雷的坐标，并且点击不是雷，还要满足一点击一片的效果。 最后需要一个函数判断是否扫雷成功。 项目展示： 是不是很有意思？当然重中之重的是： 要注意需要用二维数组来打印两个棋盘，假如我们要打印10X10的棋盘，那我们的二维数组元素也要为10X10个吗？，不能，因为我们在设计算法时需要统计坐标周围8个方位雷的个数，假如要统计边界坐标周围雷的个数，那么就会有数组越界的问题，那我们就要在10X10的边界多上一圈元素，也就要定义12X12的数组元素，这些元素我们不要打印出来，心里有数就行。 项目源码：game.h:1234567891011121314151617181920212223242526272829303132333435363738394041424344/********************************************************************************************** 项目名称：扫雷游戏 ** 编译环境：Vs 2013 ** 创建日期：2018.4.18 ** 项目编辑：Mr.Yao * ***********************************************************************************************/ //知识点： //1.数组 //2.函数 //3.循环 //4.扩展内容： 递归 (内存换取时间) #ifndef __GAME_H_ #define __GAME_H_ #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; enum opp &#123; EXIT, PLAY &#125;; #define EASY 10 #define HARD 30 #define ROW 10 #define COL 10 #define ROWS (ROW+2) #define COLS (COL+2) void InitMap(char arr[ROWS][COLS], int row,int col, char set); //创建初始化棋盘 void PrintMap(char arr[ROWS][COLS], int row, int col); //打印棋盘 void SetMy(char arr[ROWS][COLS], int row, int col, int count); //布雷 void SweepMap(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int row, int cow, int sum); //扫雷 void MoveLei(char my_map[ROWS][COLS], int x, int y); //若第一次扫到雷，则移动雷的位置 void GetCount(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int x, int y);//统计雷数 #endif game.c:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#define _CRT_SECURE_NO_WARNINGS 1 #include "game.h" //初始化棋盘void InitMap(char arr[ROWS][COLS], int row, int col, char set) &#123; memset(arr, set, col*row*sizeof(arr[0][0])); &#125; //打印棋盘void PrintMap(char arr[ROWS][COLS], int row, int col) &#123; int i = 0; int j = 0; printf(" "); for (i = 1; i&lt;=row ; i++) &#123; printf("%3d", i); &#125; printf("\n"); for (i = 0; i&lt;=row; i++) &#123; printf("---"); &#125; printf("\n"); for (i = 1; i &lt;= row; i++) &#123; printf("%2d|", i); for (j = 1; j &lt;= col ; j++) &#123; printf("%3c", arr[i][j]); &#125; printf("\n"); &#125; &#125; //布雷void SetMy(char arr[ROWS][COLS], int row, int col, int sum) &#123; int count = sum; int x = 0; int y = 0; while (count) &#123; x = rand() % row + 1; y = rand() % col + 1; if (arr[x][y] == '0') &#123; arr[x][y] = '1'; count--; &#125; &#125; &#125; //扫雷void SweepMap(char my_map[ROWS][COLS],char player_map[ROWS][COLS], int row, int col, int sum) &#123; int x = 0; int y = 0; int count = 0; int temp = 0; int win = 0; while (win &lt; (row * col - sum)) &#123; printf("请输入你扫雷坐标:&gt;"); scanf("%d%d", &amp;x, &amp;y); temp++; if (x &gt;= 1 &amp;&amp; x &lt;= row&amp;&amp;y &gt;= 1 &amp;&amp; y &lt;= col) &#123; while ((my_map[x][y] == '1') &amp;&amp; (temp == 1)) &#123; //保证玩家第一次不死 MoveLei(my_map, x, y); //对周围的雷数进行遍历 GetCount(my_map, player_map, x, y); &#125; if (my_map[x][y] == '1') &#123; printf("\n恭喜你，壮烈牺牲\n"); PrintMap(my_map, ROW, COL); break; &#125; else &#123; GetCount(my_map, player_map, x, y); printf("\n"); win++; &#125; PrintMap(player_map, ROW, COL); &#125; else &#123; printf("坐标输入有误\n"); &#125; &#125; if(win == (row * col - sum)) &#123; printf("恭喜你，排完了\n"); &#125; &#125; //若输入的坐标无雷，则要遍历周围，统计雷数 //若周围无雷，则递归遍历，统计周围雷数 void GetCount(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int x, int y) &#123; if ((my_map[x][y] == '0')) &#123; int count = 0; if (my_map[x - 1][y - 1] == '1') count++; if (my_map[x - 1][y] == '1') count++; if (my_map[x - 1][y + 1] == '1') count++; if (my_map[x][y - 1] == '1') count++; if (my_map[x][y + 1] == '1') count++; if (my_map[x + 1][y - 1] == '1') count++; if (my_map[x + 1][y] == '1') count++; if (my_map[x + 1][y + 1] == '1') count++; player_map[x][y] = (count + '0'); &#125; if (player_map[x][y] == '0') &#123; if (player_map[x - 1][y - 1] == '*') GetCount(my_map, player_map, x - 1, y - 1); if (player_map[x - 1][y] == '*') GetCount(my_map, player_map, x - 1, y); if (player_map[x - 1][y + 1] == '*') GetCount(my_map, player_map, x - 1, y + 1); if (player_map[x][y - 1] == '*') GetCount(my_map, player_map, x, y - 1); if (player_map[x][y + 1] == '*') GetCount(my_map, player_map, x, y + 1); if (player_map[x + 1][y - 1] == '*') GetCount(my_map, player_map, x + 1, y - 1); if (player_map[x + 1][y] == '*') GetCount(my_map, player_map, x + 1, y); if (player_map[x + 1][y + 1] == '*') GetCount(my_map, player_map, x + 1, y + 1); &#125; &#125; //为提高游戏体验，设置玩家第一次无论如何都不会被炸死 void MoveLei(char my_map[ROWS][COLS], int x, int y) &#123; int ret = 1; do &#123; my_map[x][y] = '0'; while (ret) &#123; x = rand() % ROW + 1; y = rand() % COL + 1; if (my_map[x][y] == '0') &#123; my_map[x][y] = '1'; &#125; ret--; &#125; &#125; while (ret); &#125; test.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define _CRT_SECURE_NO_WARNINGS 1 #include "game.h" void GotoXY(int x, int y) //设定输出位置 &#123; COORD c; c.X = x - 1; c.Y = y - 1; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c); &#125; void meau() &#123; GotoXY(10, 5); printf("开始游戏\n Let's Go!"); Sleep(1500); system("cls"); printf("**** 《扫雷》 ****\n"); printf("************************\n"); printf("******* 1.play *******\n"); printf("******* 0.exit *******\n"); printf("************************\n"); &#125; void game() &#123; int input = 0; int sum = 0; char my_map[ROWS][COLS]; char player_map[ROWS][COLS]; InitMap(my_map,ROWS,COLS,'0'); InitMap(player_map, ROWS, COLS, '*'); printf("**** 1.Easy 0.Hard *****\n"); scanf("%d", &amp;input); switch (input) &#123; case PLAY: sum = EASY; break; case EXIT: sum = HARD; break; default: printf("输入有误\n"); break; &#125; printf("\n这个棋盘有%d个雷。\n", sum); SetMy(my_map,ROW,COL,sum); PrintMap(player_map, ROW, COL); //PrintMap(my_map, ROW, COL); SweepMap(my_map,player_map ,ROW, COL, sum); system("pause"); &#125; void test() &#123; int input = 0; do &#123; meau(); printf("请选择:&gt;"); scanf("%d", &amp;input); switch (input) &#123; case PLAY: game(); break; case EXIT: break; default: printf("输出有误\n"); &#125; &#125; while (input); &#125;int main() &#123; srand((unsigned)time(NULL)); test(); system("pause"); return 0; &#125; 结语 简单利用C语言做了一个小游戏，如有不正之处，欢迎双击评论！]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>扫雷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Git命令】大全]]></title>
    <url>%2F2018%2F05%2F22%2F20180522%2F</url>
    <content type="text"><![CDATA[前言 经过搜集、整理，现得到以下Git相关知识，相互学习，相互促进。 上传日期：2018.5.22 整理员：Hunter git命令学习笔记●配置name和email$ git config –global user.name “your name” $ git config –global user.email “your email@example.com“ //–global是全局参数，表示这个账户上所以的Git仓库都使用这个配置 ●配置别名$ git config –global alias.st status ●各种状态显示不同颜色$ git config –global color.ui true ●创建并成为让Git管理的仓库$ mkdir &lt;文件名&gt; $ cd &lt;文件名&gt; $ git init//初始化一个仓库 $ ls -ah//此命令用于看见隐藏的.git ●将文件添加到Git的仓库里$ git add &lt;文件名&gt; //第一步，把文件放到暂存区 $ git commit -m”本次提交的说明” //把暂存区的所有内容提交到当前分支 ●查看工作区当前状态$ git status ●查看修改内容$ git diff 补充：查看工作区和版本库最新版本的区别 $ git diff HEAD – 文件名 ●回退版本$ git reset –hard HEAD^ //回退上一个版本 $ git reset –hard HEAD^^ //回退上上个版本 $ git reset –hard HEAD~100 //回退上100个版本 $ git reset –hard commit_id //在历史版本里任意穿梭 ●查看历史$ git log//查看提交历史 $ git log –pretty=oneline //查看简单的提交历史 $ git reflog//查看命令历史 ●丢弃工作区的修改$ git checkout – 文件名 //在没有添加到暂存区内 $ git reset HEAD 文件名 $ git checkout – 文件名 //添加到暂存区内 ●删除文件$ rm 文件名 $ git rm 文件名 //确实要删除这个文件 $ git checkout – 文件名 //误删 补充：强制删除未被合并的分支 $ git branch -D 分支名 ●生成ssh秘钥$ ssh-keygen -t rsa -C”youremail@example.com“ ●关联远程库$ git remote add origin git@githup.com:&lt;账户名&gt;/&lt;仓库名&gt;.git ●推送本地内容到远程库$ git push -u origin master //第一次推送需要加 -u参数 $ git push origin master //以后操作不用 -u参数 ●克隆仓库$ git clone git@githup.com:&lt;账户名&gt;/&lt;仓库名&gt;.git ●关于分支的命令$ git branch 分支名 //创建一个新的分支 $ git checkout 分支名 //切换分支 $ git checkout -b 分支名 //创建并切换分支 $ git branch //查看当前分支 $ git merge 分支名 //合并此分支到当前分支(Fast forward模式) $ git merge –no-ff -m”说明文字” 分支名（禁用Fast forward模式） $ git branch -d 分支名 ●查看分支合并情况$ git log –graph=oneline –abbrev-commit ●储存工作现场$ git stash//储存工作现场 $ git stash //储存工作现场的列表 $ git stash apply //恢复工作现场，stash内容不删除 $ git stash drop //删除stash的内容 $ git stash pop //恢复工作现场的同时删除stash内容 $ git stash apply stash@{0} //恢复指定stash ●查看远程库信息$ git remote $ git remote -v //查看更详细的信息 ●推送指定分支$ git push origin 分支名 ●从远程库抓取最新的提交$ git pull ●在本地创建远程分支对应分支$ git checkout -b 分支名 origin/分支名 ●建立本地分支和远程分支的关联$ git checkout -set-upstream 分支名 origin/分支名 ●关于标签的命令$ git tag 标签名 //打一个新的标签 $ git tag //查看所有标签 $ git tag 标签名 commit_id //给任意提交过的版本打标签 $ git show 标签名 //查看标签信息 $ git tag -a 标签名 -m”说明文字” commit_id //创建带有说明的标签 -a指定标签名 -m指定说明文字 $ git push origin 标签名 //推送指定标签 $ git push origin –tags //一次性推送所有标签到远程库 $ git tag -d 标签名 //删除指定标签 $ git push origin:refs/tags/标签名 //删除远程库的标签 git push origin –delete HEAD //删除分支 HEAD $ sudo rm test $ git add -u $ git commit -m “delete test” $ git push //删除服务器文件]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串左右旋转问题]]></title>
    <url>%2F2018%2F05%2F20%2F20180520%2F</url>
    <content type="text"><![CDATA[题目 实现一个函数，可以左旋字符串中的k个字符。 AABCD左旋一个字符得到ABCDA AABCD左旋两个字符得到BCDAA 方法一：【暴力移位法】算法思想：用移的步数作为while循环条件(每移1位完了减1)，1位1位的移动，即只需要一个空的变量来存移出去的字符，而这时变量i已经到了数组最后的空位置，此时把先前移出去的字符再补回来即可123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; void left_move(char *str, int k) &#123; assert(str); char temp = 0; int len = strlen(str); k = k%len; while (k--) &#123; char *cur = str; temp = *cur; while (*(cur + 1) != '\0') &#123; *cur = *(cur + 1); cur++; &#125; *cur = temp; &#125; &#125; int main() &#123; char arr[] = "abcdef"; int k = 0; scanf("%d", &amp;k); left_move(arr, k); printf("%s", arr); return 0; &#125; 方法二：【三步翻转法】算法思想：以移动的步数为界限，左边字符串整体逆置，右边字符串整体逆置，再整个字符串整体逆置，即需要调用3次整体逆置字符串函数，要注意各个逆置区间的定义 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; void reverse(char *left, char*right)//逆序 &#123; assert(left&amp;&amp;right); while (left &lt; right) &#123; char tmp; tmp = *left; *left = *right; *right = tmp; left++, right--; &#125; &#125; void reverse_left(char *str, int k) &#123; int len = 0; assert(str); len = strlen(str); k = k%len; reverse(str, (str + k - 1));//要旋转的k个字符逆序 reverse((str + k), (str + len - 1));//之后的字符逆序 reverse(str, (str + len - 1));//所有的字符逆序 &#125; int main() &#123; int k = 0; char str[] = "abcdefgh"; scanf("%d", &amp;k); reverse_left(str, k); printf("%s", str); return 0; &#125; 方法三：【穷举法】算法思想：(相当于穷举法)申请一个是原来2倍+1(算上\0)的数组空间，将原来的字符串复制一遍存在这个空间里，然后从原来的首元素加上移动的步数开始输出len个长度的字符串，完成左旋效果(先后用到strcpy strcat strncpy函数) 注意：(1)变量定义一定要放在表达式前面，否则乱报错；(2)用malloc函数申请完空间记得释放，头文件&lt;stdlib.h&gt;123456789101112131415161718192021222324252627#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; void reverse_string(char *str, int k) &#123; int len = strlen(str); char *tmp = (char*)malloc(2 * len + 1); //申请2倍的原数组空间 assert(str); strcpy(tmp, str); //把原来的字符串拷贝到这个大空间里 strcat(tmp, str); //把原来的字符串再拼接到后面(复制2遍) strncpy(str, tmp + k, len); //从要移动的位数后一位起，获取原来长度的字符串，达到左旋效果 free(tmp); &#125; int main() &#123; char arr[] = "abcdef"; int k = 0; scanf("%d", &amp;k); reverse_string(arr, k); printf("%s", arr); return 0; &#125; 结语考查字符串和字符数组的相关操作，注意在没有明确指定是否允许使用库函数的时候，就默认允许使用库函数，在不允许的情况下需要自定义实现这些函数（本题中只需要自定义实现strlen()、strstr()、strcat()这些函数），这样就很OK了！]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>字符串旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析（命令行参数 ）&&（main函数参数）]]></title>
    <url>%2F2018%2F05%2F20%2F201852222-2%2F</url>
    <content type="text"><![CDATA[前言命令行参数: ● 命令行参数是控制命令执行的一种方式。 ● 命令行参数类似于函数的参数，只是命令行参数是传送给命令的。命令执行时，内核已经将命令行参数放入命令的栈中，命令执行时则可以获取命令行参数，解析，执行。 ● 命令行参数使命令可以执行不同任务。 linux系统下的实现:12345678910111213#include &lt;stdio.h&gt; int main(int argc, char *argv[]) &#123; printf("%d\n",argc); printf("%s\n",argv[0]); printf("%s\n",argv[1]); printf("%s\n",argv[2]); &#125; 在这个例子中，我们给main函数传递两个参数：argc，argv： ● argc是int类型的，它表示的是命令行参数的个数。不许要用户传递，它会根据用户从命令行输入的参数个数，自动确定。 ● argv是char* argv[]类型的，即是指针数组类型，它的作用是存储用户从命令行传递进来的参数。它的第一个成员是程序执行的.exe文件。 ● main函数还有一个参数是envp，是一个 指针数组类型，每个元素存储指向一个环境变量的字符指针。这里不予赘述。 对于上面的例子，我们将其保存为test.c，用gcc编译生成目标文件为a.out 编译结果如下： 执行结果如下： 这里第一个输出的是argc，因为我们只输入了./a.out，所以argc为1，即只有一个命令行参数。后面输出的第一个命令行参数也是./a.out。接着程序就出错了，因为程序要说输出第二、第三参数，而后面已经没有第二个和第三个参数了，在写实际的应用时，应注意对这一部分进行容错处理。所谓容错处理就是指软件运行时，能对由非正常因素引起的运行错误给出适当的处理或信息提示，使软件运行正常结束。而这个错误也就是程序员很容易犯得段错误。 当在命令行输入./a.out、linux、nihao三个参数时，执行结果如图： 命令行参数个数为3，第一个参数./a.out、第二个参数linux、第三个参数nihao。 当输入./a.out、”linux nihao”、hehe、”hi apple”四个参数时，执行结果如图： 当输入四个参数，命令行参数个数就为4，但需要注意的是就是如果一个参数之间有空格，需要用双引号引起来，以免产生不必要的错误。 当然对于具体情况请看下图： 结语 对于main函数第二个参数argv，其数据类型可以写成三种形式：char *argv[]、char **argv、char argv[][]，当然第三个函数参数envp同理。]]></content>
      <categories>
        <category>C语言知识及题集</category>
      </categories>
      <tags>
        <tag>命令行参数 main函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2018%2F05%2F20%2FMy-First-Blog%2F</url>
    <content type="text"><![CDATA[前言 人生，走着走着便懂了，对于未来，不再迷茫彷徨，而是以更坚定的步伐迈向预定的目标；人生，走着走着便懂了，对于爱情，不再痴迷悲伤，而是以更理智的心态去接受爱情细水长流的平淡；人生，走着走着便懂了，对于生活，不再困惑感伤，而是以积极乐观的心态去迎接每一个黎明的到来。 白驹过隙，转眼间，我已是大二学生，虽然已经在大学生活了一年，却依然对未来很迷茫，这种迷茫也带来了一系列的恐惧：能否找到称心如意的工作、能否有能力赡养自己的父母，买不起房怎么办、程序员真的是青春饭吗……我是通信学院物联网工程专业的一名普通的不能再普通的学生。说实话，上大学以来，我并没有为了某些事情真正地努力过，即使是一些很简单的事情 。 曾听人说大学有四个阶段：不知道自己不知道-&gt;知道自己不知道-&gt;不知道自己知道-&gt;知道自己知道。就目前情况来看我应该处于第二阶段，我认识到自己缺乏太多的专业知识以及社交原则，我也会经常阅读搞IT的成功人士的案例来寻求安慰与激励，但这只是短暂的麻痹罢了。 曾经很“牛逼”地对好朋友说过：“我不想过一辈子穷苦生活！”现在想起当时的自己真的是既无知又可笑，我特么拿什么去过理想中的生活呢？殊不知：开水不响，响水不开。被打的人才会大吼几声来搏回一点颜面，而真正有实力的人都是深藏不露的。 小时候家里还种地的时候，我也像其他孩子一样要去田里除草。烈日炎炎下，站在田地里往前一看，我的妈，还有这么多的草要拔呀！还没干活便没了一半的力气。而如果一步一步的做好眼前的这一块，便在不知不觉中就到了地头。我现在何尝又不是当年那个拔草的少年呢，我还有海量的东西要学，我为何不能脚踏实地的学好现在的东西呢？ 现于公元二零一八年，特写此篇 ，抒己所感。我并不是为自己起初愚笨忏悔，而是把压在心里的东西排出来轻松一下，并且要警示自己从现在起，静下心来，虚心学习，因为仅剩的大学时光不多了。说实话，像我这样无实力的人连现在的生活都掌控不好，有何权利去畅想未来？关键是要把自己变强大，才能在困难面前有获胜的筹码。曾听过一句自认为非常好的话，毅然当作了自己的座右铭：人生在勤，不索何获！ 作此篇亦献给正处于迷茫中的你，希望能够共勉，一起进步!]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>人生在勤，不索何获</tag>
      </tags>
  </entry>
</search>
